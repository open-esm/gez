[{"id":300,"title":"@gez/rspack-vue","content":"#\n\nแพ็คเกจ Rspack Vue จัดเตรียมชุด API สำหรับการสร้างและกำหนดค่าแอปพลิเคชัน Rspack\nที่ใช้เฟรมเวิร์ก Vue โดยสนับสนุนการพัฒนาคอมโพเนนต์ Vue การสร้าง\nและการเรนเดอร์ฝั่งเซิร์ฟเวอร์\n\n\nการติดตั้ง#\n\nติดตั้ง @gez/rspack-vue เป็น dependency สำหรับการพัฒนาโดยใช้ package manager:\n\n\nการส่งออกประเภท#\n\n\nBuildTarget#\n\n\n\nประเภทสภาพแวดล้อมเป้าหมายการสร้าง\nกำหนดสภาพแวดล้อมเป้าหมายสำหรับการสร้างแอปพลิเคชัน\nใช้สำหรับกำหนดค่าการปรับปรุงและฟังก์ชันเฉพาะในกระบวนการสร้าง:\n\n * node: สร้างโค้ดสำหรับการทำงานในสภาพแวดล้อม Node.js\n * client: สร้างโค้ดสำหรับการทำงานในสภาพแวดล้อมเบราว์เซอร์\n * server: สร้างโค้ดสำหรับการทำงานในสภาพแวดล้อมเซิร์ฟเวอร์\n\n\nRspackAppConfigContext#\n\n\n\nอินเทอร์เฟซบริบทการกำหนดค่าแอปพลิเคชัน Rspack\nที่ให้ข้อมูลบริบทที่สามารถเข้าถึงได้ในฟังก์ชัน hook การกำหนดค่า:\n\n * gez: อินสแตนซ์ของ Gez Framework\n * buildTarget: เป้าหมายการสร้างปัจจุบัน (client/server/node)\n * config: ออบเจ็กต์การกำหนดค่า Rspack\n * options: ตัวเลือกการกำหนดค่าแอปพลิเคชัน\n\n\nRspackAppOptions#\n\n\n\nอินเทอร์เฟซตัวเลือกการกำหนดค่าแอปพลิเคชัน Rspack:\n\n * css: วิธีการส่งออก CSS สามารถเลือก 'css' (ไฟล์แยก) หรือ 'js' (รวมใน JS)\n   โดยค่าเริ่มต้นจะเลือกตามสภาพแวดล้อม: ใช้ 'css'\n   ในสภาพแวดล้อมการผลิตเพื่อเพิ่มประสิทธิภาพการแคชและการโหลดแบบขนาน ใช้ 'js'\n   ในสภาพแวดล้อมการพัฒนาเพื่อสนับสนุนการอัปเดตแบบร้อน (HMR)\n * loaders: การกำหนดค่า loader ที่กำหนดเอง\n * styleLoader: ตัวเลือกการกำหนดค่า style-loader\n * cssLoader: ตัวเลือกการกำหนดค่า css-loader\n * target: การกำหนดค่าความเข้ากันได้ของเป้าหมายการสร้าง\n * definePlugin: การกำหนดค่าค่าคงที่ทั่วโลก\n * config: ฟังก์ชัน hook การกำหนดค่า\n\n\nRspackHtmlAppOptions#\n\nสืบทอดจาก RspackAppOptions ใช้สำหรับกำหนดค่าตัวเลือกเฉพาะสำหรับแอปพลิเคชัน HTML\n\n\nการส่งออกฟังก์ชัน#\n\n\ncreateRspackApp#\n\n\n\nสร้างอินสแตนซ์แอปพลิเคชัน Rspack มาตรฐาน\n\nพารามิเตอร์:\n\n * gez: อินสแตนซ์ของ Gez Framework\n * options: ตัวเลือกการกำหนดค่าแอปพลิเคชัน Rspack\n\nค่าที่ส่งกลับ:\n\n * ส่งกลับ Promise ที่ resolve เป็นอินสแตนซ์แอปพลิเคชันที่สร้างขึ้น\n\n\ncreateRspackHtmlApp#\n\n\n\nสร้างอินสแตนซ์แอปพลิเคชัน Rspack ประเภท HTML\n\nพารามิเตอร์:\n\n * gez: อินสแตนซ์ของ Gez Framework\n * options: ตัวเลือกการกำหนดค่าแอปพลิเคชัน HTML\n\nค่าที่ส่งกลับ:\n\n * ส่งกลับ Promise ที่ resolve เป็นอินสแตนซ์แอปพลิเคชัน HTML ที่สร้างขึ้น\n\n\nการส่งออกค่าคงที่#\n\n\nRSPACK_LOADER#\n\n\n\nออบเจ็กต์แมปตัวระบุ loader ที่มีอยู่ภายใน Rspack ที่จัดเตรียมค่าคงที่ชื่อ loader\nที่ใช้บ่อย:\n\n * builtinSwcLoader: SWC loader ที่มีอยู่ภายใน Rspack ใช้สำหรับประมวลผลไฟล์\n   TypeScript/JavaScript\n * lightningcssLoader: lightningcss loader ที่มีอยู่ภายใน Rspack\n   ใช้สำหรับคอมไพล์ไฟล์ CSS ด้วยประสิทธิภาพสูง\n * styleLoader: loader ที่ใช้สำหรับฉีด CSS เข้าไปใน DOM\n * cssLoader: loader ที่ใช้สำหรับแยกวิเคราะห์ไฟล์ CSS และจัดการ CSS modules\n * lessLoader: loader ที่ใช้สำหรับคอมไพล์ไฟล์ Less เป็น CSS\n * styleResourcesLoader: loader ที่ใช้สำหรับนำเข้าแหล่งข้อมูลสไตล์ทั่วโลก (เช่น\n   ตัวแปร, mixins) โดยอัตโนมัติ\n * workerRspackLoader: loader ที่ใช้สำหรับประมวลผลไฟล์ Web Worker\n\nการใช้ค่าคงที่เหล่านี้สามารถอ้างอิง loader ที่มีอยู่ภายในในการกำหนดค่าได้\nโดยไม่ต้องป้อนสตริงด้วยตนเอง:\n\n\n\nข้อควรทราบ:\n\n * loader เหล่านี้มีอยู่ภายใน Rspack แล้ว ไม่จำเป็นต้องติดตั้งเพิ่มเติม\n * เมื่อกำหนดค่า loader ที่กำหนดเอง\n   สามารถใช้ค่าคงที่เหล่านี้เพื่อแทนที่การใช้งาน loader เริ่มต้น\n * loader บางตัว (เช่น builtinSwcLoader) มีตัวเลือกการกำหนดค่าเฉพาะ\n   ควรอ้างอิงเอกสารการกำหนดค่าที่เกี่ยวข้อง\n\n\nการส่งออกโมดูล#\n\n\nrspack#\n\nส่งออกใหม่ทั้งหมดจากแพ็คเกจ @rspack/core เพื่อให้ฟังก์ชันหลักของ Rspack ครบถ้วน","routePath":"/th/api/app/rspack-vue","lang":"th","toc":[{"text":"การติดตั้ง","id":"การติดตั้ง","depth":2,"charIndex":178},{"text":"การส่งออกประเภท","id":"การส่งออกประเภท","depth":2,"charIndex":271},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":290},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":627},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":947},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1557},{"text":"การส่งออกฟังก์ชัน","id":"การส่งออกฟังก์ชัน","depth":2,"charIndex":1662},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1683},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1931},{"text":"การส่งออกค่าคงที่","id":"การส่งออกค่าคงที่","depth":2,"charIndex":2191},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2212},{"text":"การส่งออกโมดูล","id":"การส่งออกโมดูล","depth":2,"charIndex":3315},{"text":"rspack","id":"rspack","depth":3,"charIndex":3333}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Vue Build Tool","description":"เครื่องมือสร้าง Vue เฉพาะสำหรับ Gez Framework ที่ให้การสนับสนุนการสร้างแอปพลิเคชัน Vue 2/3 อย่างครบถ้วน รวมถึงการพัฒนาคอมโพเนนต์ การเรนเดอร์ SSR และการปรับปรุงประสิทธิภาพ","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, Build Tool, Component Development, Server-Side Rendering, Performance Optimization"}]]},"version":""},{"id":301,"title":"@gez/rspack","content":"#\n\nแพ็คเกจ Rspack ให้ชุด API สำหรับการสร้างและกำหนดค่าแอปพลิเคชัน Rspack\nรองรับการสร้างและพัฒนาแอปพลิเคชันมาตรฐานและแอปพลิเคชัน HTML\n\n\nการติดตั้ง#\n\nติดตั้ง @gez/rspack เป็น dependency สำหรับการพัฒนาโดยใช้ package manager:\n\n\nการส่งออกประเภท#\n\n\nBuildTarget#\n\n\n\nประเภทสภาพแวดล้อมเป้าหมายการสร้าง กำหนดสภาพแวดล้อมเป้าหมายของแอปพลิเคชัน\nใช้สำหรับกำหนดค่าการปรับให้เหมาะสมและฟังก์ชันเฉพาะในกระบวนการสร้าง:\n\n * node: สร้างโค้ดสำหรับทำงานในสภาพแวดล้อม Node.js\n * client: สร้างโค้ดสำหรับทำงานในสภาพแวดล้อมเบราว์เซอร์\n * server: สร้างโค้ดสำหรับทำงานในสภาพแวดล้อมเซิร์ฟเวอร์\n\n\nRspackAppConfigContext#\n\n\n\nอินเทอร์เฟซบริบทการกำหนดค่าแอปพลิเคชัน Rspack\nให้ข้อมูลบริบทที่สามารถเข้าถึงได้ในฟังก์ชัน hook การกำหนดค่า:\n\n * gez: อินสแตนซ์ของ Gez framework\n * buildTarget: เป้าหมายการสร้างปัจจุบัน (client/server/node)\n * config: ออบเจ็กต์การกำหนดค่า Rspack\n * options: ตัวเลือกการกำหนดค่าแอปพลิเคชัน\n\n\nRspackAppOptions#\n\n\n\nอินเทอร์เฟซตัวเลือกการกำหนดค่าแอปพลิเคชัน Rspack:\n\n * css: วิธีการส่งออก CSS สามารถเลือก 'css' (ไฟล์แยก) หรือ 'js' (รวมใน JS)\n   โดยค่าเริ่มต้นจะเลือกตามสภาพแวดล้อม: สภาพแวดล้อมการผลิตใช้ 'css'\n   เพื่อเพิ่มประสิทธิภาพการแคชและการโหลดแบบขนาน สภาพแวดล้อมการพัฒนาจะใช้ 'js'\n   เพื่อรองรับการอัปเดตแบบร้อน (HMR)\n * loaders: การกำหนดค่า loader ที่กำหนดเอง\n * styleLoader: ตัวเลือกการกำหนดค่า style-loader\n * cssLoader: ตัวเลือกการกำหนดค่า css-loader\n * target: การกำหนดค่าความเข้ากันได้ของเป้าหมายการสร้าง\n * definePlugin: การกำหนดค่าค่าคงที่ทั่วโลก\n * config: ฟังก์ชัน hook การกำหนดค่า\n\n\nRspackHtmlAppOptions#\n\nสืบทอดจาก RspackAppOptions ใช้สำหรับกำหนดค่าตัวเลือกเฉพาะของแอปพลิเคชัน HTML\n\n\nการส่งออกฟังก์ชัน#\n\n\ncreateRspackApp#\n\n\n\nสร้างอินสแตนซ์แอปพลิเคชัน Rspack มาตรฐาน\n\nพารามิเตอร์:\n\n * gez: อินสแตนซ์ของ Gez framework\n * options: ตัวเลือกการกำหนดค่าแอปพลิเคชัน Rspack\n\nค่าที่ส่งกลับ:\n\n * ส่งกลับ Promise ที่ resolve เป็นอินสแตนซ์แอปพลิเคชันที่สร้างขึ้น\n\n\ncreateRspackHtmlApp#\n\n\n\nสร้างอินสแตนซ์แอปพลิเคชัน Rspack ประเภท HTML\n\nพารามิเตอร์:\n\n * gez: อินสแตนซ์ของ Gez framework\n * options: ตัวเลือกการกำหนดค่าแอปพลิเคชัน HTML\n\nค่าที่ส่งกลับ:\n\n * ส่งกลับ Promise ที่ resolve เป็นอินสแตนซ์แอปพลิเคชัน HTML ที่สร้างขึ้น\n\n\nการส่งออกค่าคงที่#\n\n\nRSPACK_LOADER#\n\n\n\nออบเจ็กต์แมปตัวระบุ loader ที่มีอยู่ภายใน Rspack ให้ค่าคงที่ชื่อ loader\nที่ใช้บ่อย:\n\n * builtinSwcLoader: SWC loader ที่มีอยู่ภายใน Rspack ใช้สำหรับประมวลผลไฟล์\n   TypeScript/JavaScript\n * lightningcssLoader: lightningcss loader ที่มีอยู่ภายใน Rspack\n   ใช้สำหรับคอมไพล์ไฟล์ CSS ด้วยประสิทธิภาพสูง\n * styleLoader: loader ที่ใช้สำหรับฉีด CSS เข้าไปใน DOM\n * cssLoader: loader ที่ใช้สำหรับแยกวิเคราะห์ไฟล์ CSS และจัดการโมดูล CSS\n * lessLoader: loader ที่ใช้สำหรับคอมไพล์ไฟล์ Less เป็น CSS\n * styleResourcesLoader: loader ที่ใช้สำหรับนำเข้าแหล่งข้อมูลสไตล์ทั่วโลก (เช่น\n   ตัวแปร, mixins) โดยอัตโนมัติ\n * workerRspackLoader: loader ที่ใช้สำหรับประมวลผลไฟล์ Web Worker\n\nการใช้ค่าคงที่เหล่านี้สามารถอ้างอิงถึง loader ที่มีอยู่ภายในในการกำหนดค่าได้\nโดยไม่ต้องป้อนสตริงด้วยตนเอง:\n\n\n\nข้อควรทราบ:\n\n * loader เหล่านี้มีอยู่ภายใน Rspack แล้ว ไม่จำเป็นต้องติดตั้งเพิ่มเติม\n * เมื่อกำหนดค่า loader ที่กำหนดเอง\n   สามารถใช้ค่าคงที่เหล่านี้เพื่อแทนที่การใช้งาน loader เริ่มต้น\n * loader บางตัว (เช่น builtinSwcLoader) มีตัวเลือกการกำหนดค่าเฉพาะ\n   ควรอ้างอิงเอกสารการกำหนดค่าที่เกี่ยวข้อง\n\n\nการส่งออกโมดูล#\n\n\nrspack#\n\nส่งออกใหม่ทั้งหมดจากแพ็คเกจ @rspack/core ให้ฟังก์ชันหลักทั้งหมดของ Rspack","routePath":"/th/api/app/rspack","lang":"th","toc":[{"text":"การติดตั้ง","id":"การติดตั้ง","depth":2,"charIndex":134},{"text":"การส่งออกประเภท","id":"การส่งออกประเภท","depth":2,"charIndex":223},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":242},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":565},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":882},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1488},{"text":"การส่งออกฟังก์ชัน","id":"การส่งออกฟังก์ชัน","depth":2,"charIndex":1590},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1611},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1859},{"text":"การส่งออกค่าคงที่","id":"การส่งออกค่าคงที่","depth":2,"charIndex":2119},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2140},{"text":"การส่งออกโมดูล","id":"การส่งออกโมดูล","depth":2,"charIndex":3234},{"text":"rspack","id":"rspack","depth":3,"charIndex":3252}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Rspack Build Tool","description":"Rspack build tool ของ Gez framework ให้ความสามารถในการสร้างแอปพลิเคชันที่มีประสิทธิภาพสูง รองรับการพัฒนาและสร้างแอปพลิเคชันมาตรฐานและแอปพลิเคชัน HTML พร้อมด้วยตัวประมวลผลทรัพยากรและการปรับแต่งการปรับให้เหมาะสมที่หลากหลาย","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Build Tool, Application Build, HTML Application, TypeScript, CSS, Resource Processing, Performance Optimization"}]]},"version":""},{"id":302,"title":"App","content":"#\n\nApp เป็นนามธรรมของแอปพลิเคชันใน Gez เฟรมเวิร์ก\nที่ให้อินเทอร์เฟซแบบรวมศูนย์เพื่อจัดการวงจรชีวิตแอปพลิเคชัน ทรัพยากรแบบคงที่\nและการเรนเดอร์ฝั่งเซิร์ฟเวอร์\n\n\n\n\nนิยามประเภท#\n\n\nApp#\n\n\n\nmiddleware#\n\n * ประเภท: Middleware\n\nมิดเดิลแวร์สำหรับจัดการทรัพยากรแบบคงที่\n\nสภาพแวดล้อมการพัฒนา:\n\n * จัดการคำขอทรัพยากรแบบคงที่จากซอร์สโค้ด\n * รองรับการคอมไพล์แบบเรียลไทม์และฮอตรีโหลด\n * ใช้กลยุทธ์แคชแบบ no-cache\n\nสภาพแวดล้อมการผลิต:\n\n * จัดการทรัพยากรแบบคงที่ที่ถูกสร้างแล้ว\n * รองรับการแคชระยะยาวสำหรับไฟล์ที่ไม่เปลี่ยนแปลง (.final.xxx)\n * กลยุทธ์การโหลดทรัพยากรที่ได้รับการปรับปรุง\n\n\n\nrender#\n\n * ประเภท: (options?: RenderContextOptions) => Promise\n\nฟังก์ชันการเรนเดอร์ฝั่งเซิร์ฟเวอร์ ให้การใช้งานที่แตกต่างกันตามสภาพแวดล้อม:\n\n * สภาพแวดล้อมการผลิต (start): โหลดไฟล์เข้าสู่เซิร์ฟเวอร์ที่ถูกสร้างแล้ว\n   (entry.server) เพื่อทำการเรนเดอร์\n * สภาพแวดล้อมการพัฒนา (dev):\n   โหลดไฟล์เข้าสู่เซิร์ฟเวอร์จากซอร์สโค้ดเพื่อทำการเรนเดอร์\n\n\n\nbuild#\n\n * ประเภท: () => Promise\n\nฟังก์ชันการสร้างสำหรับสภาพแวดล้อมการผลิต ใช้สำหรับการแพ็คเกจและปรับปรุงทรัพยากร\nส่งคืน true หากการสร้างสำเร็จ และ false หากล้มเหลว\n\ndestroy#\n\n * ประเภท: () => Promise\n\nฟังก์ชันการทำความสะอาดทรัพยากร ใช้สำหรับการปิดเซิร์ฟเวอร์ การตัดการเชื่อมต่อ ฯลฯ\nส่งคืน true หากการทำความสะอาดสำเร็จ และ false หากล้มเหลว","routePath":"/th/api/core/app","lang":"th","toc":[{"text":"นิยามประเภท","id":"นิยามประเภท","depth":2,"charIndex":160},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":183},{"text":"render","id":"render","depth":4,"charIndex":572},{"text":"build","id":"build","depth":4,"charIndex":917},{"text":"destroy","id":"destroy","depth":4,"charIndex":1083}],"domain":"","frontmatter":{"titleSuffix":"Gez เฟรมเวิร์กอินเทอร์เฟซแอปพลิเคชันนามธรรม","description":"รายละเอียดเกี่ยวกับอินเทอร์เฟซ App ของ Gez เฟรมเวิร์ก รวมถึงการจัดการวงจรชีวิตแอปพลิเคชัน การจัดการทรัพยากรแบบคงที่ และฟังก์ชันการเรนเดอร์ฝั่งเซิร์ฟเวอร์ เพื่อช่วยให้นักพัฒนาทำความเข้าใจและใช้ฟังก์ชันหลักของแอปพลิเคชัน","head":[["meta",{"property":"keywords","content":"Gez, App, แอปพลิเคชันนามธรรม, วงจรชีวิต, ทรัพยากรแบบคงที่, การเรนเดอร์ฝั่งเซิร์ฟเวอร์, API"}]]},"version":""},{"id":303,"title":"Gez","content":"#\n\n\nบทนำ#\n\nGez เป็นเว็บเฟรมเวิร์กประสิทธิภาพสูงที่สร้างบน Rspack\nให้ความสามารถในการจัดการวงจรชีวิตแอปพลิเคชัน การจัดการทรัพยากรคงที่\nและการเรนเดอร์ฝั่งเซิร์ฟเวอร์อย่างครบถ้วน\n\n\nนิยามประเภท#\n\n\nRuntimeTarget#\n\n * นิยามประเภท:\n\n\n\nประเภทสภาพแวดล้อมรันไทม์ของแอปพลิเคชัน:\n\n * client: ทำงานในสภาพแวดล้อมเบราว์เซอร์ รองรับการทำงานกับ DOM และ API\n   ของเบราว์เซอร์\n * server: ทำงานในสภาพแวดล้อม Node.js\n   รองรับระบบไฟล์และฟังก์ชันการทำงานฝั่งเซิร์ฟเวอร์\n\n\nImportMap#\n\n * นิยามประเภท:\n\n\n\nประเภทการแมปการนำเข้าโมดูล ES\n\nSpecifierMap#\n\n * นิยามประเภท:\n\n\n\nประเภทการแมปตัวระบุโมดูล ใช้กำหนดความสัมพันธ์การแมปเส้นทางการนำเข้าโมดูล\n\nScopesMap#\n\n * นิยามประเภท:\n\n\n\nประเภทการแมปขอบเขต ใช้กำหนดความสัมพันธ์การแมปการนำเข้าโมดูลภายในขอบเขตเฉพาะ\n\n\nCOMMAND#\n\n * นิยามประเภท:\n\n\n\nประเภท enum คำสั่ง:\n\n * dev: คำสั่งสภาพแวดล้อมการพัฒนา เริ่มเซิร์ฟเวอร์พัฒนาพร้อมการอัปเดตร้อน\n * build: คำสั่งการสร้าง สร้างผลลัพธ์สำหรับสภาพแวดล้อมการผลิต\n * preview: คำสั่งการแสดงตัวอย่าง เริ่มเซิร์ฟเวอร์แสดงตัวอย่างในเครื่อง\n * start: คำสั่งเริ่มต้น เรียกใช้เซิร์ฟเวอร์สภาพแวดล้อมการผลิต\n\n\nตัวเลือกอินสแตนซ์#\n\nกำหนดตัวเลือกการกำหนดค่าหลักของเฟรมเวิร์ก Gez\n\n\n\nroot#\n\n * ประเภท: string\n * ค่าเริ่มต้น: process.cwd()\n\nเส้นทางไดเรกทอรีรากของโปรเจกต์ สามารถเป็นเส้นทางสัมบูรณ์หรือเส้นทางสัมพัทธ์\nโดยเส้นทางสัมพัทธ์จะถูกแก้ไขตามไดเรกทอรีการทำงานปัจจุบัน\n\nisProd#\n\n * ประเภท: boolean\n * ค่าเริ่มต้น: process.env.NODE_ENV === 'production'\n\nตัวบ่งชี้สภาพแวดล้อม\n\n * true: สภาพแวดล้อมการผลิต\n * false: สภาพแวดล้อมการพัฒนา\n\nbasePathPlaceholder#\n\n * ประเภท: string | false\n * ค่าเริ่มต้น: '[[[___GEZ_DYNAMIC_BASE___]]]'\n\nการกำหนดค่าตัวยึดตำแหน่งเส้นทางฐาน\nใช้สำหรับการแทนที่เส้นทางฐานของทรัพยากรในรันไทม์ ตั้งค่าเป็น false\nเพื่อปิดใช้งานฟังก์ชันนี้\n\nmodules#\n\n * ประเภท: ModuleConfig\n\nตัวเลือกการกำหนดค่าโมดูล ใช้กำหนดกฎการแก้ไขโมดูลของโปรเจกต์ รวมถึงการกำหนดค่า\nalias ของโมดูลและ dependency ภายนอก\n\npacks#\n\n * ประเภท: PackConfig\n\nตัวเลือกการกำหนดค่าการแพ็คเกจ ใช้สำหรับการแพ็คผลลัพธ์การสร้างเป็นแพ็คเกจ .tgz\nมาตรฐานของ npm\n\ndevApp#\n\n * ประเภท: (gez: Gez) => Promise\n\nฟังก์ชันการสร้างแอปพลิเคชันสำหรับสภาพแวดล้อมการพัฒนา\nใช้เฉพาะในสภาพแวดล้อมการพัฒนา\nเพื่อสร้างอินสแตนซ์แอปพลิเคชันสำหรับเซิร์ฟเวอร์พัฒนา\n\n\n\nserver#\n\n * ประเภท: (gez: Gez) => Promise\n\nฟังก์ชันการกำหนดค่าและเริ่มต้นเซิร์ฟเวอร์ HTTP\nใช้ได้ทั้งในสภาพแวดล้อมการพัฒนาและการผลิต\n\n\n\npostBuild#\n\n * ประเภท: (gez: Gez) => Promise\n\nฟังก์ชันการประมวลผลหลังการสร้าง ทำงานหลังจากสร้างโปรเจกต์เสร็จสิ้น ใช้สำหรับ:\n\n * การประมวลผลทรัพยากรเพิ่มเติม\n * การดำเนินการ deploy\n * การสร้างไฟล์คงที่\n * การส่งการแจ้งเตือนการสร้าง\n\n\nคุณสมบัติอินสแตนซ์#\n\n\nname#\n\n * ประเภท: string\n * อ่านได้อย่างเดียว: true\n\nชื่อของโมดูลปัจจุบัน มาจากการกำหนดค่าโมดูล\n\n\nvarName#\n\n * ประเภท: string\n * อ่านได้อย่างเดียว: true\n\nชื่อตัวแปร JavaScript ที่ถูกต้องซึ่งสร้างจากชื่อโมดูล\n\n\nroot#\n\n * ประเภท: string\n * อ่านได้อย่างเดียว: true\n\nเส้นทางสัมบูรณ์ของไดเรกทอรีรากโปรเจกต์ หากกำหนดค่า root เป็นเส้นทางสัมพัทธ์\nจะถูกแก้ไขตามไดเรกทอรีการทำงานปัจจุบัน\n\n\nisProd#\n\n * ประเภท: boolean\n * อ่านได้อย่างเดียว: true\n\nตรวจสอบว่าปัจจุบันอยู่ในสภาพแวดล้อมการผลิตหรือไม่ ให้ความสำคัญกับตัวเลือก isProd\nในค่ากำหนด หากไม่มีการกำหนดค่า จะตรวจสอบจาก process.env.NODE_ENV\n\n\nbasePath#\n\n * ประเภท: string\n * อ่านได้อย่างเดียว: true\n * throw: NotReadyError - เมื่อเฟรมเวิร์กยังไม่ถูกเตรียมใช้งาน\n\nรับเส้นทางฐานของโมดูลที่ขึ้นต้นและลงท้ายด้วยเครื่องหมายทับ รูปแบบการส่งคืนคือ\n/${name}/ โดยที่ name มาจากการกำหนดค่าโมดูล\n\n\nbasePathPlaceholder#\n\n * ประเภท: string\n * อ่านได้อย่างเดียว: true\n\nรับตัวยึดตำแหน่งเส้นทางฐานสำหรับการแทนที่ในรันไทม์\nสามารถปิดใช้งานได้ผ่านการกำหนดค่า\n\n\nmiddleware#\n\n * ประเภท: Middleware\n * อ่านได้อย่างเดียว: true\n\nรับ middleware การจัดการทรัพยากรคงที่ ให้การใช้งานที่แตกต่างกันตามสภาพแวดล้อม:\n\n * สภาพแวดล้อมการพัฒนา: รองรับการคอมไพล์ซอร์สโค้ดแบบเรียลไทม์และการอัปเดตร้อน\n * สภาพแวดล้อมการผลิต: รองรับการแคชทรัพยากรคงที่ระยะยาว\n\n\n\n\nrender#\n\n * ประเภท: (options?: RenderContextOptions) => Promise\n * อ่านได้อย่างเดียว: true\n\nรับฟังก์ชันการเรนเดอร์ฝั่งเซิร์ฟเวอร์ ให้การใช้งานที่แตกต่างกันตามสภาพแวดล้อม:\n\n * สภาพแวดล้อมการพัฒนา: รองรับการอัปเดตร้อนและการแสดงตัวอย่างแบบเรียลไทม์\n * สภาพแวดล้อมการผลิต: ให้ประสิทธิภาพการเรนเดอร์ที่ได้รับการปรับปรุง\n\n\n\n\nCOMMAND#\n\n * ประเภท: typeof COMMAND\n * อ่านได้อย่างเดียว: true\n\nรับนิยามประเภท enum ของคำสั่ง\n\n\nmoduleConfig#\n\n * ประเภท: ParsedModuleConfig\n * อ่านได้อย่างเดียว: true\n * throw: NotReadyError - เมื่อเฟรมเวิร์กยังไม่ถูกเตรียมใช้งาน\n\nรับข้อมูลการกำหนดค่าโมดูลปัจจุบันทั้งหมด รวมถึงกฎการแก้ไขโมดูลและการกำหนดค่า\nalias\n\n\npackConfig#\n\n * ประเภท: ParsedPackConfig\n * อ่านได้อย่างเดียว: true\n * throw: NotReadyError - เมื่อเฟรมเวิร์กยังไม่ถูกเตรียมใช้งาน\n\nรับการกำหนดค่าที่เกี่ยวข้องกับการแพ็คเกจของโมดูลปัจจุบัน\nรวมถึงเส้นทางผลลัพธ์และการประมวลผล package.json\n\n\nเมธอดอินสแตนซ์#\n\n\nconstructor()#\n\n * พารามิเตอร์:\n   * options?: GezOptions - ตัวเลือกการกำหนดค่าเฟรมเวิร์ก\n * ส่งคืนค่า: Gez\n\nสร้างอินสแตนซ์เฟรมเวิร์ก Gez\n\n\n\n\ninit()#\n\n * พารามิเตอร์: command: COMMAND\n * ส่งคืนค่า: Promise\n * throw:\n   * Error: เมื่อพยายามเตรียมใช้งานซ้ำ\n   * NotReadyError: เมื่อเข้าถึงอินสแตนซ์ที่ยังไม่ถูกเตรียมใช้งาน\n\nเตรียมใช้งานอินสแตนซ์เฟรมเวิร์ก Gez ดำเนินการกระบวนการเตรียมใช้งานหลักดังนี้:\n\n 1. แก้ไขการกำหนดค่าโปรเจกต์ (package.json, การกำหนดค่าโมดูล,\n    การกำหนดค่าการแพ็คเกจ ฯลฯ)\n 2. สร้างอินสแตนซ์แอปพลิเคชัน (สภาพแวดล้อมการพัฒนาหรือการผลิต)\n 3. ดำเนินการเมธอดวงจรชีวิตที่สอดคล้องกับคำสั่ง\n\nข้อควรระวัง\n * การเตรียมใช้งานซ้ำจะทำให้เกิดข้อผิดพลาด\n * การเข้าถึงอินสแตนซ์ที่ยังไม่ถูกเตรียมใช้งานจะทำให้เกิด NotReadyError\n\n\n\n\ndestroy()#\n\n * ส่งคืนค่า: Promise\n\nทำลายอินสแตนซ์เฟรมเวิร์ก Gez ดำเนินการล้างทรัพยากรและปิดการเชื่อมต่อ ใช้สำหรับ:\n\n * ปิดเซิร์ฟเวอร์พัฒนา\n * ล้างไฟล์ชั่วคราวและแคช\n * ปลดปล่อยทรัพยากรระบบ\n\n\n\n\nbuild()#\n\n * ส่งคืนค่า: Promise\n\nดำเนินการกระบวนการสร้างแอปพลิเคชัน รวมถึง:\n\n * คอมไพล์ซอร์สโค้ด\n * สร้างผลลัพธ์สำหรับสภาพแวดล้อมการผลิต\n * ปรับปรุงและบีบอัดโค้ด\n * สร้างรายการทรัพยากร\n\nข้อควรระวัง\n\nการเรียกใช้เมื่ออินสแตนซ์เฟรมเวิร์กยังไม่ถูกเตรียมใช้งานจะทำให้เกิด\nNotReadyError\n\n\n\n\nserver()#\n\n * ส่งคืนค่า: Promise\n * throw: NotReadyError - เมื่อเฟรมเวิร์กยังไม่ถูกเตรียมใช้งาน\n\nเริ่มต้นเซิร์ฟเวอร์ HTTP และกำหนดค่าอินสแตนซ์เซิร์ฟเวอร์\nถูกเรียกใช้ในวงจรชีวิตต่อไปนี้:\n\n * สภาพแวดล้อมการพัฒนา (dev): เริ่มต้นเซิร์ฟเวอร์พัฒนา ให้การอัปเดตร้อน\n * สภาพแวดล้อมการผลิต (start): เริ่มต้นเซิร์ฟเวอร์การผลิต\n   ให้ประสิทธิภาพระดับการผลิต\n\n\n\n\npostBuild()#\n\n * ส่งคืนค่า: Promise\n\nดำเนินการตรรกะการประมวลผลหลังการสร้าง ใช้สำหรับ:\n\n * สร้างไฟล์ HTML คงที่\n * ประมวลผลผลลัพธ์การสร้าง\n * ดำเนินการ deploy\n * ส่งการแจ้งเตือนการสร้าง\n\n\n\n\nresolvePath#\n\nแก้ไขเส้นทางโปรเจกต์ แปลงเส้นทางสัมพัทธ์เป็นเส้นทางสัมบูรณ์\n\n * พารามิเตอร์:\n   \n   * projectPath: ProjectPath - ประเภทเส้นทางโปรเจกต์\n   * ...args: string[] - ส่วนของเส้นทาง\n\n * ส่งคืนค่า: string - เส้นทางสัมบูรณ์ที่แก้ไขแล้ว\n\n * ตัวอย่าง:\n\n\n\n\nwriteSync()#\n\nเขียนเนื้อหาไฟล์แบบซิงโครนัส\n\n * พารามิเตอร์:\n   \n   * filepath: string - เส้นทางสัมบูรณ์ของไฟล์\n   * data: any - ข้อมูลที่จะเขียน สามารถเป็นสตริง, Buffer หรือออบเจ็กต์\n\n * ส่งคืนค่า: boolean - การเขียนสำเร็จหรือไม่\n\n * ตัวอย่าง:\n\n\n\n\nreadJsonSync()#\n\nอ่านและแยกวิเคราะห์ไฟล์ JSON แบบซิงโครนัส\n\n * พารามิเตอร์:\n   \n   * filename: string - เส้นทางสัมบูรณ์ของไฟล์ JSON\n\n * ส่งคืนค่า: any - ออบเจ็กต์ JSON ที่แยกวิเคราะห์แล้ว\n\n * throw: เมื่อไฟล์ไม่มีอยู่หรือรูปแบบ JSON ผิดพลาด\n\n * ตัวอย่าง:\n\n\n\n\nreadJson()#\n\nอ่านและแยกวิเคราะห์ไฟล์ JSON แบบอะซิงโครนัส\n\n * พารามิเตอร์:\n   \n   * filename: string - เส้นทางสัมบูรณ์ของไฟล์ JSON\n\n * ส่งคืนค่า: Promise - อ","routePath":"/th/api/core/gez","lang":"th","toc":[{"text":"บทนำ","id":"บทนำ","depth":2,"charIndex":3},{"text":"นิยามประเภท","id":"นิยามประเภท","depth":2,"charIndex":176},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":191},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":448},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":510},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":618},{"text":"COMMAND","id":"command","depth":3,"charIndex":727},{"text":"ตัวเลือกอินสแตนซ์","id":"ตัวเลือกอินสแตนซ์","depth":2,"charIndex":1050},{"text":"root","id":"root","depth":4,"charIndex":1119},{"text":"isProd","id":"isprod","depth":4,"charIndex":1309},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":1473},{"text":"modules","id":"modules","depth":4,"charIndex":1698},{"text":"packs","id":"packs","depth":4,"charIndex":1848},{"text":"devApp","id":"devapp","depth":4,"charIndex":1973},{"text":"server","id":"server","depth":4,"charIndex":2155},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":2290},{"text":"คุณสมบัติอินสแตนซ์","id":"คุณสมบัติอินสแตนซ์","depth":2,"charIndex":2523},{"text":"name","id":"name","depth":3,"charIndex":2545},{"text":"varName","id":"varname","depth":3,"charIndex":2643},{"text":"root","id":"root-1","depth":3,"charIndex":2755},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":2925},{"text":"basePath","id":"basepath","depth":3,"charIndex":3129},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":3373},{"text":"middleware","id":"middleware","depth":3,"charIndex":3528},{"text":"render","id":"render","depth":3,"charIndex":3809},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":4128},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":4224},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":4445},{"text":"เมธอดอินสแตนซ์","id":"เมธอดอินสแตนซ์","depth":2,"charIndex":4684},{"text":"constructor()","id":"constructor","depth":3,"charIndex":4702},{"text":"init()","id":"init","depth":3,"charIndex":4844},{"text":"destroy()","id":"destroy","depth":3,"charIndex":5439},{"text":"build()","id":"build","depth":3,"charIndex":5632},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":6457},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":6716},{"text":"readJsonSync()","id":"readjsonsync","depth":3,"charIndex":6964},{"text":"readJson()","id":"readjson","depth":3,"charIndex":7223}],"domain":"","frontmatter":{"titleSuffix":"กรอบ API คลาสหลัก","description":"รายละเอียด API คลาสหลักของเฟรมเวิร์ก Gez รวมถึงการจัดการวงจรชีวิตแอปพลิเคชัน การจัดการทรัพยากรคงที่ และความสามารถในการเรนเดอร์ฝั่งเซิร์ฟเวอร์ ช่วยให้นักพัฒนาทำความเข้าใจฟังก์ชันหลักของเฟรมเวิร์กได้อย่างลึกซึ้ง","head":[["meta",{"property":"keywords","content":"Gez, API, การจัดการวงจรชีวิต, ทรัพยากรคงที่, การเรนเดอร์ฝั่งเซิร์ฟเวอร์, Rspack, เว็บเฟรมเวิร์ก"}]]},"version":""},{"id":304,"title":"ManifestJson","content":"#\n\nmanifest.json เป็นไฟล์รายการที่สร้างขึ้นในกระบวนการ build ของเฟรมเวิร์ค Gez\nใช้สำหรับบันทึกข้อมูลผลลัพธ์ของการ build บริการ\nไฟล์นี้ให้อินเทอร์เฟซที่มาตรฐานสำหรับการจัดการผลลัพธ์ build, ไฟล์ที่ export\nและสถิติขนาดทรัพยากร\n\n\n\n\nนิยามประเภท#\n\n\nManifestJson#\n\n\n\nname#\n\n * ประเภท: string\n\nชื่อบริการ มาจากการกำหนดค่า GezOptions.name\n\nexports#\n\n * ประเภท: Record\n\nความสัมพันธ์การแมปไฟล์ที่ export ออกไป โดย key คือ path ของไฟล์ต้นฉบับ และ value\nคือ path ของไฟล์หลัง build\n\nbuildFiles#\n\n * ประเภท: string[]\n\nรายการไฟล์ผลลัพธ์ build ที่สมบูรณ์ ประกอบด้วย path ของไฟล์ทั้งหมดที่สร้างขึ้น\n\nchunks#\n\n * ประเภท: Record\n\nความสัมพันธ์ระหว่างไฟล์ต้นฉบับกับผลลัพธ์การ compile โดย key คือ path\nของไฟล์ต้นฉบับ และ value คือข้อมูลการ compile\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * ประเภท: string\n\npath ของไฟล์ JS ที่ compile จากไฟล์ต้นฉบับปัจจุบัน\n\ncss#\n\n * ประเภท: string[]\n\nรายการ path ของไฟล์ CSS ที่เกี่ยวข้องกับไฟล์ต้นฉบับปัจจุบัน\n\nresources#\n\n * ประเภท: string[]\n\nรายการ path ของไฟล์ทรัพยากรอื่นๆ ที่เกี่ยวข้องกับไฟล์ต้นฉบับปัจจุบัน\n\nsizes#\n\n * ประเภท: ManifestJsonChunkSizes\n\nข้อมูลสถิติขนาดของผลลัพธ์ build\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * ประเภท: number\n\nขนาดไฟล์ JS (หน่วย: ไบต์)\n\ncss#\n\n * ประเภท: number\n\nขนาดไฟล์ CSS (หน่วย: ไบต์)\n\nresource#\n\n * ประเภท: number\n\nขนาดไฟล์ทรัพยากร (หน่วย: ไบต์)","routePath":"/th/api/core/manifest-json","lang":"th","toc":[{"text":"นิยามประเภท","id":"นิยามประเภท","depth":2,"charIndex":227},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":259},{"text":"exports","id":"exports","depth":4,"charIndex":330},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":468},{"text":"chunks","id":"chunks","depth":4,"charIndex":581},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":726},{"text":"js","id":"js","depth":4,"charIndex":749},{"text":"css","id":"css","depth":4,"charIndex":825},{"text":"resources","id":"resources","depth":4,"charIndex":913},{"text":"sizes","id":"sizes","depth":4,"charIndex":1016},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":1093},{"text":"js","id":"js-1","depth":4,"charIndex":1120},{"text":"css","id":"css-1","depth":4,"charIndex":1171},{"text":"resource","id":"resource","depth":4,"charIndex":1224}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Build Manifest File Reference","description":"Detailed explanation of the build manifest file (manifest.json) structure in Gez framework, including build artifact management, export file mapping, and resource statistics, helping developers understand and use the build system.","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, Build Manifest, Resource Management, Build Artifacts, File Mapping, API"}]]},"version":""},{"id":305,"title":"ModuleConfig","content":"#\n\nModuleConfig ให้ฟังก์ชันการกำหนดค่าโมดูลสำหรับเฟรมเวิร์ก Gez\nใช้เพื่อกำหนดกฎการนำเข้าและส่งออกโมดูล การกำหนดค่าชื่อแฝง และการพึ่งพาภายนอก\n\n\nนิยามประเภท#\n\n\nPathType#\n\n * นิยามประเภท:\n\n\n\nการแจงนับประเภทเส้นทางโมดูล:\n\n * npm: หมายถึงการพึ่งพาใน node_modules\n * root: หมายถึงไฟล์ในไดเรกทอรีรากของโปรเจกต์\n\n\nModuleConfig#\n\n * นิยามประเภท:\n\n\n\nอินเทอร์เฟซการกำหนดค่าโมดูล ใช้เพื่อกำหนดค่าการส่งออก การนำเข้า\nและการพึ่งพาภายนอกของบริการ\n\nexports#\n\nรายการกำหนดค่าการส่งออก เปิดเผยหน่วยโค้ดเฉพาะในบริการ (เช่น คอมโพเนนต์\nฟังก์ชันเครื่องมือ ฯลฯ) ในรูปแบบ ESM\n\nรองรับสองประเภท:\n\n * root:*: ส่งออกไฟล์ซอร์สโค้ด เช่น 'root:src/components/button.vue'\n * npm:*: ส่งออกการพึ่งพาบุคคลที่สาม เช่น 'npm:vue'\n\nimports#\n\nการแมปกำหนดค่าการนำเข้า กำหนดค่าโมดูลระยะไกลที่ต้องการนำเข้าและเส้นทางท้องถิ่น\n\nวิธีการติดตั้งต่างกัน การกำหนดค่าก็ต่างกัน:\n\n * การติดตั้งซอร์สโค้ด (Workspace, Git): ต้องชี้ไปที่ไดเรกทอรี dist\n * การติดตั้งแพ็คเกจ (Link, เซิร์ฟเวอร์แบบคงที่, แหล่งกระจายส่วนตัว, File):\n   ชี้ไปที่ไดเรกทอรีแพ็คเกจโดยตรง\n\nexternals#\n\nการแมปการพึ่งพาภายนอก กำหนดค่าการพึ่งพาภายนอกที่ต้องการใช้\nมักจะใช้การพึ่งพาจากโมดูลระยะไกล\n\nตัวอย่าง:\n\n\n\n\nParsedModuleConfig#\n\n * นิยามประเภท:\n\n\n\nการกำหนดค่าโมดูลที่ถูกแยกวิเคราะห์\nแปลงการกำหนดค่าโมดูลดั้งเดิมเป็นรูปแบบภายในที่มาตรฐาน:\n\nname#\n\nชื่อของบริการปัจจุบัน\n\n * ใช้เพื่อระบุโมดูลและสร้างเส้นทางการนำเข้า\n\nroot#\n\nเส้นทางไดเรกทอรีรากของบริการปัจจุบัน\n\n * ใช้เพื่อแยกวิเคราะห์เส้นทางสัมพัทธ์และที่เก็บผลลัพธ์การสร้าง\n\nexports#\n\nรายการกำหนดค่าการส่งออก\n\n * name: เส้นทางการส่งออกดั้งเดิม เช่น 'npm:vue' หรือ 'root:src/components'\n * type: ประเภทเส้นทาง (npm หรือ root)\n * importName: ชื่อการนำเข้า รูปแบบ: '${serviceName}/${type}/${path}'\n * exportName: เส้นทางการส่งออก เทียบกับไดเรกทอรีรากของบริการ\n * exportPath: เส้นทางไฟล์จริง\n * externalName: ชื่อการพึ่งพาภายนอก\n   ใช้เพื่อระบุโมดูลนี้เมื่อนำเข้าโดยบริการอื่น\n\nimports#\n\nรายการกำหนดค่าการนำเข้า\n\n * name: ชื่อของบริการภายนอก\n * localPath: เส้นทางเก็บท้องถิ่น ใช้เพื่อเก็บผลลัพธ์การสร้างของโมดูลภายนอก\n\nexternals#\n\nการแมปการพึ่งพาภายนอก\n\n * แมปเส้นทางการนำเข้าโมดูลไปยังตำแหน่งโมดูลจริง\n * match: นิพจน์ทั่วไปที่ใช้เพื่อจับคู่คำสั่งนำเข้า\n * import: เส้นทางโมดูลจริง","routePath":"/th/api/core/module-config","lang":"th","toc":[{"text":"นิยามประเภท","id":"นิยามประเภท","depth":2,"charIndex":142},{"text":"PathType","id":"pathtype","depth":3,"charIndex":157},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":432},{"text":"imports","id":"imports","depth":4,"charIndex":691},{"text":"externals","id":"externals","depth":4,"charIndex":1005},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":1124},{"text":"name","id":"name","depth":4,"charIndex":1255},{"text":"root","id":"root","depth":4,"charIndex":1331},{"text":"exports","id":"exports-1","depth":4,"charIndex":1441},{"text":"imports","id":"imports-1","depth":4,"charIndex":1840},{"text":"externals","id":"externals-1","depth":4,"charIndex":1981}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Module Configuration API Reference","description":"รายละเอียดเกี่ยวกับอินเทอร์เฟซการกำหนดค่า ModuleConfig ของเฟรมเวิร์ก Gez รวมถึงกฎการนำเข้าและส่งออกโมดูล การกำหนดค่าชื่อแฝง และการจัดการการพึ่งพาภายนอก ช่วยให้นักพัฒนาทำความเข้าใจระบบโมดูลของเฟรมเวิร์กได้อย่างลึกซึ้ง","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, การกำหนดค่าโมดูล, การนำเข้าและส่งออกโมดูล, การพึ่งพาภายนอก, การกำหนดค่าชื่อแฝง, การจัดการการพึ่งพา, Web Application Framework"}]]},"version":""},{"id":306,"title":"PackConfig","content":"#\n\nPackConfig เป็นอินเทอร์เฟซการกำหนดค่าการแพ็คเกจซอฟต์แวร์\nใช้สำหรับแพ็คผลลัพธ์การสร้างบริการเป็นแพ็คเกจซอฟต์แวร์รูปแบบมาตรฐาน .tgz ของ npm\n\n * มาตรฐาน: ใช้รูปแบบการแพ็ค .tgz มาตรฐานของ npm\n * ความสมบูรณ์: รวมไฟล์ที่จำเป็นทั้งหมด เช่น ซอร์สโค้ดโมดูล ไฟล์ประกาศประเภท\n   และไฟล์กำหนดค่า\n * ความเข้ากันได้: เข้ากันได้อย่างสมบูรณ์กับระบบนิเวศ npm\n   และรองรับเวิร์กโฟลว์การจัดการแพ็คเกจมาตรฐาน\n\n\nนิยามประเภท#\n\n\n\n\nPackConfig#\n\nenable#\n\nเปิดใช้งานฟังก์ชันการแพ็คเกจหรือไม่\nเมื่อเปิดใช้งานจะแพ็คผลลัพธ์การสร้างเป็นแพ็คเกจซอฟต์แวร์รูปแบบมาตรฐาน .tgz ของ\nnpm\n\n * ประเภท: boolean\n * ค่าเริ่มต้น: false\n\noutputs#\n\nระบุเส้นทางไฟล์แพ็คเกจซอฟต์แวร์ที่ต้องการส่งออก รองรับการกำหนดค่าดังต่อไปนี้:\n\n * string: เส้นทางส่งออกเดียว เช่น 'dist/versions/my-app.tgz'\n * string[]: เส้นทางส่งออกหลายเส้นทาง ใช้สำหรับสร้างหลายเวอร์ชันพร้อมกัน\n * boolean: เมื่อเป็น true จะใช้เส้นทางเริ่มต้น\n   'dist/client/versions/latest.tgz'\n\npackageJson#\n\nฟังก์ชันคอลแบ็กสำหรับกำหนดค่าเนื้อหา package.json โดยกำหนดเอง\nจะถูกเรียกใช้ก่อนการแพ็คเกจ เพื่อกำหนดค่าเนื้อหา package.json เอง\n\n * พารามิเตอร์:\n   * gez: Gez - อินสแตนซ์ Gez\n   * pkg: any - เนื้อหา package.json ดั้งเดิม\n * ค่าส่งกลับ: Promise - เนื้อหา package.json ที่แก้ไขแล้ว\n\nการใช้งานทั่วไป:\n\n * แก้ไขชื่อและหมายเลขเวอร์ชันแพ็คเกจ\n * เพิ่มหรืออัปเดต dependencies\n * เพิ่มฟิลด์ที่กำหนดเอง\n * กำหนดค่าข้อมูลการเผยแพร่\n\nตัวอย่าง:\n\n\n\nonBefore#\n\nฟังก์ชันคอลแบ็กสำหรับการเตรียมการก่อนการแพ็คเกจ\n\n * พารามิเตอร์:\n   * gez: Gez - อินสแตนซ์ Gez\n   * pkg: Record - เนื้อหา package.json\n * ค่าส่งกลับ: Promise\n\nการใช้งานทั่วไป:\n\n * เพิ่มไฟล์เพิ่มเติม (README, LICENSE เป็นต้น)\n * ดำเนินการทดสอบหรือตรวจสอบการสร้าง\n * สร้างเอกสารหรือเมตาดาต้า\n * ล้างไฟล์ชั่วคราว\n\nตัวอย่าง:\n\n\n\nonAfter#\n\nฟังก์ชันคอลแบ็กสำหรับการประมวลผลหลังการแพ็คเกจเสร็จสิ้น\nจะถูกเรียกใช้หลังจากสร้างไฟล์ .tgz แล้ว ใช้สำหรับประมวลผลผลลัพธ์การแพ็คเกจ\n\n * พารามิเตอร์:\n   * gez: Gez - อินสแตนซ์ Gez\n   * pkg: Record - เนื้อหา package.json\n   * file: Buffer - เนื้อหาไฟล์ที่แพ็คแล้ว\n * ค่าส่งกลับ: Promise\n\nการใช้งานทั่วไป:\n\n * เผยแพร่ไปยัง npm registry (สาธารณะหรือส่วนตัว)\n * อัปโหลดไปยังเซิร์ฟเวอร์ทรัพยากรสถิต\n * ดำเนินการจัดการเวอร์ชัน\n * เรียกใช้งานกระบวนการ CI/CD\n\nตัวอย่าง:\n\n\n\n\nตัวอย่างการใช้งาน#\n\n","routePath":"/th/api/core/pack-config","lang":"th","toc":[{"text":"นิยามประเภท","id":"นิยามประเภท","depth":2,"charIndex":393},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":423},{"text":"outputs","id":"outputs","depth":4,"charIndex":594},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":904},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":1354},{"text":"onAfter","id":"onafter","depth":4,"charIndex":1689},{"text":"ตัวอย่างการใช้งาน","id":"ตัวอย่างการใช้งาน","depth":2,"charIndex":2163}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Packaging Configuration API Reference","description":"รายละเอียดเกี่ยวกับอินเทอร์เฟซการกำหนดค่า PackConfig ของเฟรมเวิร์ก Gez รวมถึงกฎการแพ็คเกจซอฟต์แวร์ การกำหนดค่าผลลัพธ์ และฮุควงจรชีวิต ช่วยให้นักพัฒนาสามารถดำเนินกระบวนการสร้างมาตรฐานได้","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, การแพ็คเกจซอฟต์แวร์, การกำหนดค่าการสร้าง, ฮุควงจรชีวิต, การกำหนดค่าแพ็คเกจ, เว็บแอปพลิเคชันเฟรมเวิร์ก"}]]},"version":""},{"id":307,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/th/api/core/render-context","lang":"th","toc":[{"text":"นิยามประเภท","id":"นิยามประเภท","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"ตัวเลือกอินสแตนซ์","id":"ตัวเลือกอินสแตนซ์","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"คุณสมบัติอินสแตนซ์","id":"คุณสมบัติอินสแตนซ์","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"เมธอดอินสแตนซ์","id":"เมธอดอินสแตนซ์","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1},{"text":"commit()","id":"commit","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Render Context API Reference","description":"Detailed explanation of the RenderContext core class in the Gez framework, including rendering control, resource management, state synchronization, and routing control, helping developers achieve efficient server-side rendering.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, Server-Side Rendering, Rendering Context, State Synchronization, Resource Management, Web Application Framework"}]]},"version":""},{"id":308,"title":"จากส่วนประกอบที่ใช้ร่วมกันสู่โมดูลแบบเนทีฟ: เส้นทางวิวัฒนาการของเฟรมเวิร์กไมโครฟรอนต์เอนด์ Gez","content":"จากส่วนประกอบที่ใช้ร่วมกันสู่โมดูลแบบเนทีฟ:\nเส้นทางวิวัฒนาการของเฟรมเวิร์กไมโครฟรอนต์เอนด์ Gez#\n\n\nภูมิหลังของโครงการ#\n\nในช่วงหลายปีที่ผ่านมา สถาปัตยกรรมไมโครฟรอนต์เอนด์ได้พยายามหาทางที่ถูกต้อง\nอย่างไรก็ตาม สิ่งที่เราเห็นคือโซลูชันทางเทคนิคที่ซับซ้อนต่างๆ\nที่ใช้การห่อหุ้มและการแยกส่วนด้วยมือเพื่อจำลองโลกของไมโครฟรอนต์เอนด์ในอุดมคติ\nโซลูชันเหล่านี้ได้นำมาซึ่งภาระด้านประสิทธิภาพที่หนักหน่วง\nทำให้การพัฒนาที่เรียบง่ายกลายเป็นเรื่องซับซ้อน\nและทำให้กระบวนการมาตรฐานกลายเป็นเรื่องที่เข้าใจยาก\n\n\nข้อจำกัดของโซลูชันแบบดั้งเดิม#\n\nในการปฏิบัติตามสถาปัตยกรรมไมโครฟรอนต์เอนด์\nเราได้สัมผัสกับข้อจำกัดมากมายของโซลูชันแบบดั้งเดิม:\n\n * การสูญเสียประสิทธิภาพ: การ inject dependencies ใน runtime, การใช้ JavaScript\n   sandbox proxy ทุกการดำเนินการล้วนแต่ใช้ทรัพยากรประสิทธิภาพที่มีค่า\n * การแยกส่วนที่เปราะบาง: สภาพแวดล้อม sandbox ที่สร้างขึ้นด้วยมือ\n   ไม่สามารถเทียบเคียงกับความสามารถในการแยกส่วนแบบเนทีฟของเบราว์เซอร์ได้\n * ความซับซ้อนในการ build: เพื่อจัดการกับความสัมพันธ์ของ dependencies\n   จำเป็นต้องปรับแต่งเครื่องมือ build\n   ทำให้โครงการที่เรียบง่ายกลายเป็นเรื่องที่ดูแลรักษายาก\n * กฎที่ปรับแต่งเอง: กลยุทธ์การ deploy ที่พิเศษ การประมวลผลใน runtime\n   ทำให้ทุกขั้นตอนเบี่ยงเบนไปจากกระบวนการพัฒนามาตรฐานสมัยใหม่\n * ข้อจำกัดของ ecosystem: การผูกมัดกับเฟรมเวิร์ก, API ที่ปรับแต่งเอง\n   ทำให้การเลือกเทคโนโลยีถูกผูกมัดกับ ecosystem เฉพาะ\n\nปัญหาเหล่านี้ปรากฏชัดเจนในโครงการระดับองค์กรของเราในปี 2019 ในเวลานั้น\nผลิตภัณฑ์ขนาดใหญ่ถูกแบ่งออกเป็นระบบย่อยทางธุรกิจอิสระกว่า 10 ระบบ\nซึ่งระบบย่อยเหล่านี้จำเป็นต้องใช้ชุดคอมโพเนนต์พื้นฐานและคอมโพเนนต์ทางธุรกิจร่วมก\nัน โซลูชันการแชร์คอมโพเนนต์ที่ใช้ npm package\nในตอนแรกได้เผยให้เห็นปัญหาด้านประสิทธิภาพในการบำรุงรักษาอย่างรุนแรง:\nเมื่อคอมโพเนนต์ที่แชร์มีการอัปเดต\nระบบย่อยทั้งหมดที่พึ่งพาคอมโพเนนต์นี้จำเป็นต้องผ่านกระบวนการ build และ deploy\nที่สมบูรณ์\n\n\nการพัฒนาทางเทคนิค#\n\n\nv1.0: การสำรวจ Remote Component#\n\nเพื่อแก้ปัญหาประสิทธิภาพในการแชร์คอมโพเนนต์ Gez v1.0 ได้แนะนำกลไก RemoteView\ncomponent ที่ใช้โปรโตคอล HTTP โซลูชันนี้ได้แก้ปัญหาห่วงโซ่ dependencies\nที่ยาวเกินไปในการ build ผ่านการร้องขอโค้ดแบบไดนามิกใน runtime อย่างไรก็ตาม\nเนื่องจากขาดกลไกการสื่อสารใน runtime ที่เป็นมาตรฐาน\nการซิงโครไนซ์สถานะและการส่งผ่านเหตุการณ์ระหว่างเซอร์วิสยังคงมีปัญหาด้านประสิทธิภ\nาพ\n\n\nv2.0: การทดลอง Module Federation#\n\nในเวอร์ชัน v2.0 เราได้ใช้เทคโนโลยี Module Federation ของ Webpack 5.0\nเทคโนโลยีนี้ได้ปรับปรุงประสิทธิภาพการทำงานร่วมกันระหว่างเซอร์วิสอย่างมีนัยสำคัญผ\n่านกลไกการโหลดโมดูลที่รวมเป็นหนึ่งเดียวและคอนเทนเนอร์ใน runtime อย่างไรก็ตาม\nในการปฏิบัติจริงในวงกว้าง การใช้งาน Module Federation\nแบบปิดได้นำมาซึ่งความท้าทายใหม่: การจัดการเวอร์ชัน dependencies\nที่แม่นยำเป็นเรื่องยาก โดยเฉพาะอย่างยิ่งเมื่อต้องการรวม dependencies\nที่แชร์กันระหว่างหลายเซอร์วิส มักจะพบปัญหาความขัดแย้งของเวอร์ชันและข้อผิดพลาดใน\nruntime\n\n\nการก้าวสู่ยุคใหม่ของ ESM#\n\nในการวางแผนเวอร์ชัน v3.0 เราได้สังเกตแนวโน้มการพัฒนา ecosystem ด้าน frontend\nอย่างลึกซึ้ง\nและพบว่าความก้าวหน้าของความสามารถแบบเนทีฟของเบราว์เซอร์ได้นำมาซึ่งความเป็นไปได้ใ\nหม่สำหรับสถาปัตยกรรมไมโครฟรอนต์เอนด์:\n\n\nระบบโมดูลที่เป็นมาตรฐาน#\n\nด้วยการสนับสนุน ES Modules อย่างเต็มรูปแบบจากเบราว์เซอร์หลัก\nและความสมบูรณ์ของมาตรฐาน Import Maps การพัฒนา frontend\nได้เข้าสู่ยุคโมดูลาร์ที่แท้จริง ตามสถิติจาก Can I Use ปัจจุบันเบราว์เซอร์หลัก\n(Chrome >= 89, Edge >= 89, Firefox >= 108, Safari >= 16.4) มีอัตราการสนับสนุน\nESM แบบเนทีฟถึง 93.5% ซึ่งให้ประโยชน์ดังต่อไปนี้:\n\n * การจัดการ dependencies ที่เป็นมาตรฐาน: Import Maps ให้ความสามารถในการ resolve\n   dependencies ของโมดูลในระดับเบราว์เซอร์ โดยไม่ต้อง inject ที่ซับซ้อนใน\n   runtime\n * การปรับปรุงประสิทธิภาพการโหลดทรัพยากร: กลไกการแคชโมดูลแบบเนทีฟของเบราว์เซอร์\n   ช่วยปรับปรุงประสิทธิภาพการโหลดทรัพยากรอย่างมีนัยสำคัญ\n * การทำให้กระบวนการ build ง่ายขึ้น: โหมดการพัฒนาที่ใช้ ESM ทำให้กระบวนการ build\n   ของสภาพแวดล้อมการพัฒนาและสภาพแวดล้อมการผลิตมีความสอดคล้องกันมากขึ้น\n\nนอกจากนี้ ผ่านการสนับสนุนโหมดความเข้ากันได้ (Chrome >= 87, Edge >= 88, Firefox\n>= 78, Safari >= 14) เราสามารถเพิ่มอัตราการครอบคลุมของเบราว์เซอร์ได้ถึง 96.81%\nซึ่งทำให้เราสามารถรักษาประสิทธิภาพสูงได้โดยไม่เสียการสนับสนุนเบราว์เซอร์รุ่นเก่า\n\n\nความก้าวหน้าในด้านประสิทธิภาพและการแยกส่วน#\n\nระบบโมดูลแบบเนทีฟไม่ได้นำมาซึ่งเพียงแค่มาตรฐานเท่านั้น\nแต่ยังรวมถึงการปรับปรุงประสิทธิภาพและการแยกส่วนที่สำคัญ:\n\n * ไม่มีค่าใช้จ่ายใน runtime: ลาก่อน JavaScript sandbox proxy และการ inject ใน\n   runtime ของโซลูชันไมโครฟรอนต์เอนด์แบบดั้งเดิม\n * กลไกการแยกส่วนที่เชื่อถือได้: ขอบเขตโมดูลที่เข้มงวดของ ESM\n   ให้ความสามารถในการแยกส่วนที่เชื่อถือได้มากที่สุด\n * การจัดการ dependencies ที่แม่นยำ: การวิเคราะห์ static import\n   ทำให้ความสัมพันธ์ของ dependencies ชัดเจนขึ้น\n   และการควบคุมเวอร์ชันมีความแม่นยำมากขึ้น\n\n\nการเลือกเครื่องมือ build#\n\nในการนำโซลูชันทางเทคนิคไปปฏิบัติ การเลือกเครื่องมือ build\nเป็นจุดตัดสินใจที่สำคัญ จากการวิจัยและปฏิบัติทางเทคนิคเกือบหนึ่งปี\nการเลือกของเราได้ผ่านการพัฒนาดังต่อไปนี้:\n\n 1. การสำรวจ Vite\n    \n    * ข้อดี: development server ที่ใช้ ESM ให้ประสบการณ์การพัฒนาที่ดีเยี่ยม\n    * ความท้าทาย: ความแตกต่างระหว่างการ build ในสภาพแวดล้อมการพัฒนาและการผลิต\n      ทำให้เกิดความไม่แน่นอนบางประการ\n\n 2. การเลือก Rspack\n    \n    * ข้อได้เปรียบด้านประสิทธิภาพ: การคอมไพล์ประสิทธิภาพสูงที่ใช้ Rust\n      ช่วยปรับปรุงความเร็วในการ build อย่างมีนัยสำคัญ\n    * การสนับสนุน ecosystem: ความเข้ากันได้สูงกับ ecosystem ของ Webpack\n      ช่วยลดต้นทุนการย้ายระบบ\n    * การสนับสนุน ESM: ผ่านการปฏิบัติจริงของโครงการ Rslib\n      ได้ยืนยันความน่าเชื่อถือในการ build ที่ใช้ ESM\n\nการตัดสินใจนี้ทำให้เราสามารถรักษาประสบการณ์การพัฒนาได้\nในขณะที่ได้รับการสนับสนุนสภาพแวดล้อมการผลิตที่เสถียรมากขึ้น ด้วยการรวมกันของ ESM\nและ Rspack\nในที่สุดเราก็ได้สร้างโซลูชันไมโครฟรอนต์เอนด์ที่มีประสิทธิภาพสูงและมีการรบกวนต่ำ\n\n\nทิศทางในอนาคต#\n\nในแผนการพัฒนาของ Gez เฟรมเวิร์กจะมุ่งเน้นไปที่สามทิศทางหลักต่อไปนี้:\n\n\nการปรับปรุง Import Maps อย่างลึกซึ้ง#\n\n * การจัดการ dependencies แบบไดนามิก: การจัดตารางเวอร์ชัน dependencies ใน\n   runtime อย่างชาญฉลาด เพื่อแก้ปัญหาความขัดแย้งของ dependencies\n   ระหว่างแอปพลิเคชันหลายตัว\n * กลยุทธ์การโหลดล่วงหน้า: การโหลดล่วงหน้าที่ใช้การวิเคราะห์เส้นทาง\n   เพื่อปรับปรุงประสิทธิภาพการโหลดทรัพยากร\n * การปรับปรุงการ build: การสร้างการกำหนดค่า Import Maps ที่ดีที่สุดโดยอัตโนมัติ\n   เพื่อลดต้นทุนการกำหนดค่าด้วยมือของนักพัฒนา\n\n\nโซลูชัน routing ที่ไม่ขึ้นกับเฟรมเวิร์ก#\n\n * การ abstraction routing ที่รวมเป็นหนึ่งเดียว: การออกแบบอินเทอร์เฟซ routing\n   ที่ไม่ขึ้นกับเฟรมเวิร์ก เพื่อสนับสนุนเฟรมเวิร์กหลักเช่น Vue, React\n * การ routing ของไมโครแอปพลิเคชัน: การทำงานร่วมกันของ routing\n   ระหว่างแอปพลิเคชัน เพื่อรักษาความสอดคล้องระหว่าง URL และสถานะของแอปพลิเคชัน\n * middleware routing: การจัดเตรียมกลไก middleware ที่ขยายได้\n   เพื่อสนับสนุนการควบคุมสิทธิ์ การเปลี่ยนหน้า และฟังก์ชันอื่นๆ\n\n\nแนวปฏิบัติที่ดีที่สุดในการสื่อสารข้ามเฟรมเวิร์ก#\n\n * แอปพลิเคชันตัวอย่าง: การจัดเตรียมตัวอย่างการสื่อสารข้ามเฟรมเวิร์กที่สมบูรณ์\n   ครอบคลุมเฟรมเวิร์กหลักเช่น Vue, React, Preact\n * การซิงโครไนซ์สถานะ: โซลูชันการแชร์สถานะแบบเบาที่ใช้ ESM\n * event bus: กลไกการสื่อสารเหตุการณ์ที่เป็นมาตรฐาน\n   เพื่อสนับสนุนการสื่อสารที่แยกส่วนระหว่างแอปพลิเคชัน\n\nด้วยการปรับปรุงและขยายเหล่านี้ เราหวังว่า Gez\nจะกลายเป็นโซลูชันไมโครฟรอนต์เอนด์ที่สมบูรณ์และใช้งานง่ายมากขึ้น\nเพื่อมอบประสบการณ์การพัฒนาที่ดีขึ้นและประสิทธิภาพการพัฒนาที่สูงขึ้นให้กับนักพัฒน\nา","routePath":"/th/blog/birth-of-gez","lang":"th","toc":[{"text":"ภูมิหลังของโครงการ","id":"ภูมิหลังของโครงการ","depth":2,"charIndex":97},{"text":"ข้อจำกัดของโซลูชันแบบดั้งเดิม","id":"ข้อจำกัดของโซลูชันแบบดั้งเดิม","depth":3,"charIndex":490},{"text":"การพัฒนาทางเทคนิค","id":"การพัฒนาทางเทคนิค","depth":2,"charIndex":1786},{"text":"v1.0: การสำรวจ Remote Component","id":"v10-การสำรวจ-remote-component","depth":3,"charIndex":1807},{"text":"v2.0: การทดลอง Module Federation","id":"v20-การทดลอง-module-federation","depth":3,"charIndex":2203},{"text":"การก้าวสู่ยุคใหม่ของ ESM","id":"การก้าวสู่ยุคใหม่ของ-esm","depth":2,"charIndex":2742},{"text":"ระบบโมดูลที่เป็นมาตรฐาน","id":"ระบบโมดูลที่เป็นมาตรฐาน","depth":3,"charIndex":2980},{"text":"ความก้าวหน้าในด้านประสิทธิภาพและการแยกส่วน","id":"ความก้าวหน้าในด้านประสิทธิภาพและการแยกส่วน","depth":3,"charIndex":4026},{"text":"การเลือกเครื่องมือ build","id":"การเลือกเครื่องมือ-build","depth":3,"charIndex":4583},{"text":"ทิศทางในอนาคต","id":"ทิศทางในอนาคต","depth":2,"charIndex":5587},{"text":"การปรับปรุง Import Maps อย่างลึกซึ้ง","id":"การปรับปรุง-import-maps-อย่างลึกซึ้ง","depth":3,"charIndex":5674},{"text":"โซลูชัน routing ที่ไม่ขึ้นกับเฟรมเวิร์ก","id":"โซลูชัน-routing-ที่ไม่ขึ้นกับเฟรมเวิร์ก","depth":3,"charIndex":6121},{"text":"แนวปฏิบัติที่ดีที่สุดในการสื่อสารข้ามเฟรมเวิร์ก","id":"แนวปฏิบัติที่ดีที่สุดในการสื่อสารข้ามเฟรมเวิร์ก","depth":3,"charIndex":6581}],"domain":"","frontmatter":{"titleSuffix":"จากปัญหาของไมโครฟรอนต์เอนด์สู่การสร้างสรรค์ด้วย ESM: เส้นทางวิวัฒนาการของเฟรมเวิร์ก Gez","description":"ศึกษาลึกถึงการพัฒนาของเฟรมเวิร์ก Gez จากปัญหาของสถาปัตยกรรมไมโครฟรอนต์เอนด์แบบดั้งเดิมสู่การสร้างสรรค์ด้วย ESM พร้อมแบ่งปันประสบการณ์ทางเทคนิคด้านการปรับปรุงประสิทธิภาพ การจัดการ dependencies และการเลือกเครื่องมือ build","head":[["meta",{"property":"keywords","content":"Gez, ไมโครฟรอนต์เอนด์เฟรมเวิร์ก, ESM, Import Maps, Rspack, Module Federation, การจัดการ dependencies, การปรับปรุงประสิทธิภาพ, การพัฒนาทางเทคนิค, การเรนเดอร์ฝั่งเซิร์ฟเวอร์"}]],"sidebar":false},"version":""},{"id":309,"title":"ทีมบล็อก","content":"#\n\nยินดีต้อนรับสู่บล็อกเทคโนโลยีของทีม Gez!\nที่นี่เราจะแบ่งปันประสบการณ์ในกระบวนการพัฒนาเฟรมเวิร์ก นวัตกรรมทางเทคโนโลยี\nและวิธีปฏิบัติที่ดีที่สุด\n\n\nบทความล่าสุด#\n\n * 2025-02-25 จากส่วนประกอบที่ใช้ร่วมกันสู่โมดูลาร์แบบเนทีฟ:\n   เส้นทางวิวัฒนาการของเฟรมเวิร์กไมโครฟรอนต์เอนด์ Gez\n   \n   > สำรวจเส้นทางวิวัฒนาการของเฟรมเวิร์ก Gez\n   > จากส่วนประกอบที่ใช้ร่วมกันแบบดั้งเดิมสู่โมดูลาร์แบบเนทีฟที่ใช้ ESM\n   > แบ่งปันประสบการณ์ทางเทคนิคในด้านการปรับปรุงประสิทธิภาพ การจัดการการพึ่งพา\n   > และการเลือกเครื่องมือสร้าง","routePath":"/th/blog/","lang":"th","toc":[{"text":"บทความล่าสุด","id":"บทความล่าสุด","depth":2,"charIndex":147}],"domain":"","frontmatter":{"titleSuffix":"Gez ทีมบล็อก","description":"บล็อกเทคโนโลยีของทีม Gez แบ่งปันประสบการณ์การพัฒนาเฟรมเวิร์ก วิธีปฏิบัติที่ดีที่สุด และนวัตกรรมทางเทคโนโลยี","head":[["meta",{"property":"keywords","content":"Gez, ทีมบล็อก, การแบ่งปันเทคโนโลยี, วิธีปฏิบัติที่ดีที่สุด, ประสบการณ์การพัฒนา"}]],"sidebar":false},"version":""},{"id":310,"title":"Path Alias","content":"#\n\nPath Alias\nเป็นกลไกการแมปเส้นทางนำเข้าโมดูลที่อนุญาตให้นักพัฒนาใช้ตัวระบุที่สั้นและมีความหม\nายแทนเส้นทางโมดูลแบบเต็ม ใน Gez กลไก Path Alias มีข้อดีดังต่อไปนี้:\n\n * ทำให้เส้นทางนำเข้าเรียบง่ายขึ้น: ใช้ชื่อที่มีความหมายแทนเส้นทางสัมพัทธ์ที่ยาว\n   ช่วยเพิ่มความอ่านง่ายของโค้ด\n * หลีกเลี่ยงการซ้อนกันหลายชั้น:\n   ลดความยุ่งยากในการบำรุงรักษาที่เกิดจากการอ้างอิงไดเรกทอรีหลายระดับ (เช่น\n   ../../../../)\n * ความปลอดภัยของประเภท: ผสานรวมกับระบบประเภทของ TypeScript อย่างสมบูรณ์\n   ให้การเติมโค้ดอัตโนมัติและการตรวจสอบประเภท\n * เพิ่มประสิทธิภาพการแก้ไขโมดูล:\n   เพิ่มประสิทธิภาพการแก้ไขโมดูลผ่านการแมปเส้นทางที่กำหนดไว้ล่วงหน้า\n\n\nกลไกการตั้งชื่อเริ่มต้น#\n\nGez ใช้กลไกการตั้งชื่ออัตโนมัติตามชื่อบริการ (Service Name)\nซึ่งการออกแบบนี้มีลักษณะดังต่อไปนี้:\n\n * การกำหนดค่าอัตโนมัติ: สร้างชื่ออัตโนมัติจากฟิลด์ name ใน package.json\n   ไม่จำเป็นต้องกำหนดค่าด้วยตนเอง\n * มาตรฐานที่สม่ำเสมอ:\n   รับรองว่าโมดูลบริการทั้งหมดปฏิบัติตามมาตรฐานการตั้งชื่อและการอ้างอิงที่สม่ำเส\n   มอ\n * การสนับสนุนประเภท: ร่วมกับคำสั่ง npm run build:dts\n   สร้างไฟล์ประกาศประเภทอัตโนมัติ เพื่อให้ได้การอนุมานประเภทข้ามบริการ\n * ความสามารถในการคาดการณ์: สามารถคาดการณ์เส้นทางอ้างอิงโมดูลผ่านชื่อบริการ\n   ช่วยลดต้นทุนการบำรุงรักษา\n\n\nคำอธิบายการกำหนดค่า#\n\n\nการกำหนดค่าใน package.json#\n\nใน package.json กำหนดชื่อบริการผ่านฟิลด์ name\nซึ่งชื่อนี้จะใช้เป็นคำนำหน้าเริ่มต้นสำหรับชื่อบริการ:\n\n\n\n\nการกำหนดค่าใน tsconfig.json#\n\nเพื่อให้ TypeScript สามารถแก้ไขเส้นทางชื่อได้อย่างถูกต้อง จำเป็นต้องกำหนดค่า\npaths ใน tsconfig.json:\n\n\n\n\nตัวอย่างการใช้งาน#\n\n\nการนำเข้าโมดูลภายในบริการ#\n\n\n\n\nการนำเข้าโมดูลจากบริการอื่น#\n\n\n\nวิธีปฏิบัติที่ดีที่สุด\n * ใช้เส้นทางชื่อแทนเส้นทางสัมพัทธ์เป็นหลัก\n * รักษาความหมายและความสม่ำเสมอของเส้นทางชื่อ\n * หลีกเลี่ยงการใช้ระดับไดเรกทอรีมากเกินไปในเส้นทางชื่อ\n\n\n\n\nการนำเข้าข้ามบริการ#\n\nเมื่อกำหนดค่าการเชื่อมโยงโมดูล (Module Link) แล้ว\nสามารถใช้วิธีเดียวกันในการนำเข้าโมดูลจากบริการอื่น:\n\n\n\n\nการกำหนดชื่อเอง#\n\nสำหรับแพ็คเกจของบุคคลที่สามหรือสถานการณ์พิเศษ สามารถกำหนดชื่อเองผ่านไฟล์กำหนดค่า\nGez:\n\n\n\nข้อควรระวัง\n 1. สำหรับโมดูลธุรกิจ แนะนำให้ใช้กลไกการตั้งชื่อเริ่มต้นเสมอ\n    เพื่อรักษาความสม่ำเสมอของโครงการ\n 2. การกำหนดชื่อเอง主要用于ใช้สำหรับจัดการความต้องการพิเศษของแพ็คเกจของบุคคลที่สามหร\n    ือเพิ่มประสิทธิภาพประสบการณ์การพัฒนา\n 3. การใช้การกำหนดชื่อเองมากเกินไปอาจส่งผลกระทบต่อการบำรุงรักษาโค้ดและการเพิ่มปร\n    ะสิทธิภาพการสร้าง","routePath":"/th/guide/essentials/alias","lang":"th","toc":[{"text":"กลไกการตั้งชื่อเริ่มต้น","id":"กลไกการตั้งชื่อเริ่มต้น","depth":2,"charIndex":626},{"text":"คำอธิบายการกำหนดค่า","id":"คำอธิบายการกำหนดค่า","depth":2,"charIndex":1199},{"text":"การกำหนดค่าใน package.json","id":"การกำหนดค่าใน-packagejson","depth":3,"charIndex":1222},{"text":"การกำหนดค่าใน tsconfig.json","id":"การกำหนดค่าใน-tsconfigjson","depth":3,"charIndex":1355},{"text":"ตัวอย่างการใช้งาน","id":"ตัวอย่างการใช้งาน","depth":2,"charIndex":1490},{"text":"การนำเข้าโมดูลภายในบริการ","id":"การนำเข้าโมดูลภายในบริการ","depth":3,"charIndex":1511},{"text":"การนำเข้าโมดูลจากบริการอื่น","id":"การนำเข้าโมดูลจากบริการอื่น","depth":3,"charIndex":1542},{"text":"การนำเข้าข้ามบริการ","id":"การนำเข้าข้ามบริการ","depth":3,"charIndex":1747},{"text":"การกำหนดชื่อเอง","id":"การกำหนดชื่อเอง","depth":3,"charIndex":1875}],"domain":"","frontmatter":{"titleSuffix":"คู่มือการแมปเส้นทางนำเข้าโมดูลของเฟรมเวิร์ก Gez","description":"รายละเอียดเกี่ยวกับกลไกการตั้งชื่อเส้นทาง (Path Alias) ในเฟรมเวิร์ก Gez รวมถึงคุณสมบัติต่าง ๆ เช่น การทำให้เส้นทางนำเข้าเรียบง่ายขึ้น การหลีกเลี่ยงการซ้อนกันหลายชั้น ความปลอดภัยของประเภท และการเพิ่มประสิทธิภาพการแก้ไขโมดูล เพื่อช่วยให้นักพัฒนาสามารถบำรุงรักษาโค้ดได้ดีขึ้น","head":[["meta",{"property":"keywords","content":"Gez, Path Alias, TypeScript, การนำเข้าโมดูล, การแมปเส้นทาง, การบำรุงรักษาโค้ด"}]]},"version":""},{"id":311,"title":"เส้นทางพื้นฐาน","content":"#\n\nเส้นทางพื้นฐาน (Base Path) หมายถึงคำนำหน้าเส้นทางการเข้าถึงทรัพยากรคงที่ (เช่น\nJavaScript, CSS, รูปภาพ ฯลฯ) ในแอปพลิเคชัน ใน Gez\nการกำหนดค่าเส้นทางพื้นฐานอย่างเหมาะสมมีความสำคัญสำหรับสถานการณ์ต่อไปนี้:\n\n * การปรับใช้หลายสภาพแวดล้อม: รองรับการเข้าถึงทรัพยากรในสภาพแวดล้อมต่างๆ เช่น\n   สภาพแวดล้อมการพัฒนา การทดสอบ และการผลิต\n * การปรับใช้หลายภูมิภาค:\n   ปรับให้เหมาะสมกับความต้องการการปรับใช้คลัสเตอร์ในภูมิภาคหรือประเทศต่างๆ\n * การกระจาย CDN: ทำให้สามารถกระจายและเร่งความเร็วทรัพยากรคงที่ทั่วโลก\n\n\nกลไกเส้นทางเริ่มต้น#\n\nGez ใช้กลไกการสร้างเส้นทางอัตโนมัติตามชื่อบริการ\nโดยค่าเริ่มต้นเฟรมเวิร์กจะอ่านฟิลด์ name ในไฟล์ package.json\nของโปรเจกต์เพื่อสร้างเส้นทางพื้นฐานสำหรับทรัพยากรคงที่: /your-app-name/\n\n\n\nการออกแบบที่เน้นการตกลงมากกว่าการกำหนดค่านี้มีข้อดีดังต่อไปนี้:\n\n * ความสม่ำเสมอ: รับประกันว่าทรัพยากรคงที่ทั้งหมดใช้เส้นทางการเข้าถึงเดียวกัน\n * ความคาดเดาได้: สามารถคาดเดาเส้นทางการเข้าถึงทรัพยากรได้จากฟิลด์ name ใน\n   package.json\n * การบำรุงรักษาที่ง่าย: ไม่ต้องกำหนดค่าเพิ่มเติม ลดต้นทุนการบำรุงรักษา\n\n\nการกำหนดค่าเส้นทางแบบไดนามิก#\n\nในโปรเจกต์จริง\nเรามักต้องปรับใช้โค้ดชุดเดียวกันในสภาพแวดล้อมหรือภูมิภาคที่แตกต่างกัน Gez\nรองรับเส้นทางพื้นฐานแบบไดนามิก\nทำให้แอปพลิเคชันสามารถปรับตัวให้เข้ากับสถานการณ์การปรับใช้ที่แตกต่างกันได้\n\n\nสถานการณ์การใช้งาน#\n\nการปรับใช้ในไดเรกทอรีย่อย#\n\n\n\nการปรับใช้โดเมนแยก#\n\n\n\n\nวิธีการกำหนดค่า#\n\nผ่านพารามิเตอร์ base ของเมธอด gez.render()\nคุณสามารถตั้งค่าเส้นทางพื้นฐานแบบไดนามิกตามบริบทของคำขอ:\n\n","routePath":"/th/guide/essentials/base-path","lang":"th","toc":[{"text":"กลไกเส้นทางเริ่มต้น","id":"กลไกเส้นทางเริ่มต้น","depth":2,"charIndex":500},{"text":"การกำหนดค่าเส้นทางแบบไดนามิก","id":"การกำหนดค่าเส้นทางแบบไดนามิก","depth":2,"charIndex":1015},{"text":"สถานการณ์การใช้งาน","id":"สถานการณ์การใช้งาน","depth":3,"charIndex":1243},{"text":"การปรับใช้ในไดเรกทอรีย่อย","id":"การปรับใช้ในไดเรกทอรีย่อย","depth":4,"charIndex":1264},{"text":"การปรับใช้โดเมนแยก","id":"การปรับใช้โดเมนแยก","depth":4,"charIndex":1294},{"text":"วิธีการกำหนดค่า","id":"วิธีการกำหนดค่า","depth":3,"charIndex":1318}],"domain":"","frontmatter":{"titleSuffix":"คู่มือการกำหนดเส้นทางทรัพยากรคงที่ของเฟรมเวิร์ก Gez","description":"คำอธิบายโดยละเอียดเกี่ยวกับการกำหนดค่าเส้นทางพื้นฐานของเฟรมเวิร์ก Gez รวมถึงการปรับใช้หลายสภาพแวดล้อม การกระจาย CDN และการตั้งค่าเส้นทางการเข้าถึงทรัพยากร เพื่อช่วยให้นักพัฒนาสามารถจัดการทรัพยากรคงที่ได้อย่างยืดหยุ่น","head":[["meta",{"property":"keywords","content":"Gez, เส้นทางพื้นฐาน, Base Path, CDN, ทรัพยากรคงที่, การปรับใช้หลายสภาพแวดล้อม, การจัดการทรัพยากร"}]]},"version":""},{"id":312,"title":"การเรนเดอร์ฝั่งไคลเอ็นต์","content":"\n${rc.importmap()} // แผนที่การนำเข้า ${rc.moduleEntry()} // โมดูลทางเข้า\n${rc.modulePreload()} // โมดูลโหลดล่วงหน้า","routePath":"/th/guide/essentials/csr","lang":"th","toc":[{"text":"สถานการณ์ที่แนะนำให้ใช้","id":"สถานการณ์ที่แนะนำให้ใช้","depth":2,"charIndex":-1},{"text":"คำอธิบายการกำหนดค่า","id":"คำอธิบายการกำหนดค่า","depth":2,"charIndex":-1},{"text":"การกำหนดค่าเทมเพลต HTML","id":"การกำหนดค่าเทมเพลต-html","depth":3,"charIndex":-1},{"text":"การสร้าง HTML แบบสแตติก","id":"การสร้าง-html-แบบสแตติก","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"คู่มือการใช้งานการเรนเดอร์ฝั่งไคลเอ็นต์ของเฟรมเวิร์ก Gez","description":"รายละเอียดเกี่ยวกับกลไกการเรนเดอร์ฝั่งไคลเอ็นต์ของเฟรมเวิร์ก Gez รวมถึงการสร้างแบบสแตติก กลยุทธ์การปรับใช้ และแนวปฏิบัติที่ดีที่สุด เพื่อช่วยให้นักพัฒนาสามารถทำการเรนเดอร์ส่วนหน้าได้อย่างมีประสิทธิภาพในสภาพแวดล้อมที่ไม่มีเซิร์ฟเวอร์","head":[["meta",{"property":"keywords","content":"Gez, การเรนเดอร์ฝั่งไคลเอ็นต์, CSR, การสร้างแบบสแตติก, การเรนเดอร์ส่วนหน้า, การปรับใช้แบบไม่มีเซิร์ฟเวอร์, การปรับปรุงประสิทธิภาพ"}]]},"version":""},{"id":313,"title":"การเชื่อมโยงโมดูล","content":"#\n\nGez Framework มีกลไกการเชื่อมโยงโมดูลที่สมบูรณ์สำหรับการจัดการการแชร์โค้ดและ\ndependencies ระหว่างเซอร์วิส กลไกนี้ถูกพัฒนาบนพื้นฐานของ ESM (ECMAScript Module)\nspecification ซึ่งรองรับการ export และ import โมดูลในระดับ source code\nพร้อมทั้งมีฟังก์ชันการจัดการ dependencies ที่ครบถ้วน\n\n\nแนวคิดหลัก#\n\nการ export โมดูล#\n\nการ export โมดูลคือกระบวนการที่โค้ดบางส่วนในเซอร์วิส (เช่น components, utility\nfunctions) ถูกเปิดเผยสู่ภายนอกในรูปแบบ ESM รองรับการ export 2 ประเภท:\n\n * การ export source code: export ไฟล์ source code โดยตรงจากโปรเจค\n * การ export dependencies: export third-party dependencies ที่ใช้ในโปรเจค\n\nการ import โมดูล#\n\nการ import โมดูลคือกระบวนการที่เซอร์วิสหนึ่งนำเข้าโค้ดที่ถูก export\nจากเซอร์วิสอื่น รองรับวิธีการติดตั้งหลายแบบ:\n\n * การติดตั้ง source code: เหมาะสำหรับสภาพแวดล้อมการพัฒนา รองรับการแก้ไขและ hot\n   update แบบ real-time\n * การติดตั้ง package: เหมาะสำหรับสภาพแวดล้อม production ใช้ build artifacts\n   โดยตรง\n\n\nกลไกการโหลดล่วงหน้า#\n\nเพื่อเพิ่มประสิทธิภาพของเซอร์วิส Gez ได้นำกลไกการโหลดล่วงหน้าที่ชาญฉลาดมาใช้:\n\n 1. การวิเคราะห์ dependencies\n    \n    * วิเคราะห์ความสัมพันธ์ของ dependencies ระหว่าง components ในระหว่างการ\n      build\n    * ระบุ core modules บน critical path\n    * กำหนดลำดับความสำคัญในการโหลดโมดูล\n\n 2. กลยุทธ์การโหลด\n    \n    * โหลดทันที: core modules บน critical path\n    * โหลดล่าช้า: modules ที่ไม่ใช่ฟังก์ชันหลัก\n    * โหลดตามต้องการ: modules ที่แสดงผลตามเงื่อนไข\n\n 3. การปรับปรุงทรัพยากร\n    \n    * กลยุทธ์การแบ่งโค้ดอย่างชาญฉลาด\n    * การจัดการแคชในระดับโมดูล\n    * การ compile และ bundle ตามความต้องการ\n\n\nการ export โมดูล#\n\n\nคำอธิบายการตั้งค่า#\n\nตั้งค่าโมดูลที่ต้องการ export ใน entry.node.ts:\n\n\n\nการตั้งค่า export รองรับ 2 ประเภท:\n\n * root:*: export source code โดยระบุ path จาก root directory ของโปรเจค\n * npm:*: export third-party dependencies โดยระบุชื่อ package โดยตรง\n\n\nการ import โมดูล#\n\n\nคำอธิบายการตั้งค่า#\n\nตั้งค่าโมดูลที่ต้องการ import ใน entry.node.ts:\n\n\n\nคำอธิบายการตั้งค่า:\n\n 1. imports: ตั้งค่า local path ของ remote modules\n    \n    * source code installation: ชี้ไปที่ build artifacts directory (dist)\n    * package installation: ชี้ไปที่ package directory โดยตรง\n\n 2. externals: ตั้งค่า external dependencies\n    \n    * สำหรับแชร์ dependencies จาก remote modules\n    * เพื่อหลีกเลี่ยงการ bundle dependencies ซ้ำ\n    * รองรับการแชร์ dependencies ระหว่างหลายโมดูล\n\n\nวิธีการติดตั้ง#\n\nการติดตั้ง source code#\n\nเหมาะสำหรับสภาพแวดล้อมการพัฒนา รองรับการแก้ไขและ hot update แบบ real-time\n\n 1. Workspace วิธี แนะนำให้ใช้ใน Monorepo projects:\n\n\n\n 2. Link วิธี ใช้สำหรับการ debug ในเครื่อง:\n\n\n\nการติดตั้ง package#\n\nเหมาะสำหรับสภาพแวดล้อม production ใช้ build artifacts โดยตรง\n\n 1. NPM Registry ติดตั้งผ่าน npm registry:\n\n\n\n 2. Static Server ติดตั้งผ่าน HTTP/HTTPS protocol:\n\n\n\n\nการ build package#\n\n\nคำอธิบายการตั้งค่า#\n\nตั้งค่า build options ใน entry.node.ts:\n\n\n\n\nBuild Artifacts#\n\n\n\n\nกระบวนการเผยแพร่#\n\n\n\n\nแนวปฏิบัติที่ดีที่สุด#\n\n\nการตั้งค่าสภาพแวดล้อมการพัฒนา#\n\n * การจัดการ dependencies\n   \n   * ใช้ Workspace หรือ Link วิธีในการติดตั้ง dependencies\n   * จัดการ version ของ dependencies ให้เป็นเอกภาพ\n   * หลีกเลี่ยงการติดตั้ง dependencies ซ้ำซ้อน\n\n * ประสบการณ์การพัฒนา\n   \n   * เปิดใช้งาน hot update\n   * ตั้งค่า pre-loading strategy ที่เหมาะสม\n   * ปรับปรุงความเร็วในการ build\n\n\nการตั้งค่าสภาพแวดล้อม production#\n\n * กลยุทธ์การ deploy\n   \n   * ใช้ NPM Registry หรือ static server\n   * ตรวจสอบความสมบูรณ์ของ build artifacts\n   * ใช้กลไกการเผยแพร่แบบ gradual (gray release)\n\n * การปรับปรุงประสิทธิภาพ\n   \n   * ตั้งค่า resource pre-loading อย่างเหมาะสม\n   * ปรับปรุงลำดับการโหลดโมดูล\n   * ใช้ caching strategy ที่มีประสิทธิภาพ\n\n\nการจัดการ version#\n\n * มาตรฐาน versioning\n   \n   * ปฏิบัติตาม semantic versioning\n   * รักษา changelog ให้ละเอียด\n   * ทดสอบความเข้ากันได้ของ version อย่างรอบคอบ\n\n * การอัปเดต dependencies\n   \n   * อัปเดต dependencies เป็นประจำ\n   * ดำเนินการ security audit เป็นระยะ\n   * รักษาความสม่ำเสมอของ dependency versions","routePath":"/th/guide/essentials/module-link","lang":"th","toc":[{"text":"แนวคิดหลัก","id":"แนวคิดหลัก","depth":3,"charIndex":286},{"text":"การ export โมดูล","id":"การ-export-โมดูล","depth":4,"charIndex":299},{"text":"การ import โมดูล","id":"การ-import-โมดูล","depth":4,"charIndex":611},{"text":"กลไกการโหลดล่วงหน้า","id":"กลไกการโหลดล่วงหน้า","depth":3,"charIndex":937},{"text":"การ export โมดูล","id":"การ-export-โมดูล-1","depth":2,"charIndex":1557},{"text":"คำอธิบายการตั้งค่า","id":"คำอธิบายการตั้งค่า","depth":3,"charIndex":1577},{"text":"การ import โมดูล","id":"การ-import-โมดูล-1","depth":2,"charIndex":1828},{"text":"คำอธิบายการตั้งค่า","id":"คำอธิบายการตั้งค่า-1","depth":3,"charIndex":1848},{"text":"วิธีการติดตั้ง","id":"วิธีการติดตั้ง","depth":3,"charIndex":2334},{"text":"การติดตั้ง source code","id":"การติดตั้ง-source-code","depth":4,"charIndex":2351},{"text":"การติดตั้ง package","id":"การติดตั้ง-package","depth":4,"charIndex":2553},{"text":"การ build package","id":"การ-build-package","depth":2,"charIndex":2737},{"text":"คำอธิบายการตั้งค่า","id":"คำอธิบายการตั้งค่า-2","depth":3,"charIndex":2758},{"text":"Build Artifacts","id":"build-artifacts","depth":3,"charIndex":2823},{"text":"กระบวนการเผยแพร่","id":"กระบวนการเผยแพร่","depth":3,"charIndex":2844},{"text":"แนวปฏิบัติที่ดีที่สุด","id":"แนวปฏิบัติที่ดีที่สุด","depth":2,"charIndex":2866},{"text":"การตั้งค่าสภาพแวดล้อมการพัฒนา","id":"การตั้งค่าสภาพแวดล้อมการพัฒนา","depth":3,"charIndex":2891},{"text":"การตั้งค่าสภาพแวดล้อม production","id":"การตั้งค่าสภาพแวดล้อม-production","depth":3,"charIndex":3244},{"text":"การจัดการ version","id":"การจัดการ-version","depth":3,"charIndex":3591}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework ระบบการแชร์โค้ดระหว่างเซอร์วิส","description":"อธิบายรายละเอียดเกี่ยวกับกลไกการเชื่อมโยงโมดูลของ Gez Framework รวมถึงการแชร์โค้ดระหว่างเซอร์วิส การจัดการ dependencies และการใช้งาน ESM specification เพื่อช่วยให้นักพัฒนาสามารถสร้างแอปพลิเคชัน micro-frontend ที่มีประสิทธิภาพ","head":[["meta",{"property":"keywords","content":"Gez, Module Link, ESM, การแชร์โค้ด, การจัดการ dependencies, micro-frontend"}]]},"version":""},{"id":314,"title":"RenderContext","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/th/guide/essentials/render-context","lang":"th","toc":[{"text":"วิธีการใช้งาน","id":"วิธีการใช้งาน","depth":2,"charIndex":-1},{"text":"ฟังก์ชันหลัก","id":"ฟังก์ชันหลัก","depth":2,"charIndex":-1},{"text":"การรวบรวมการอ้างอิง","id":"การรวบรวมการอ้างอิง","depth":3,"charIndex":-1},{"text":"การรวบรวมตามต้องการ","id":"การรวบรวมตามต้องการ","depth":4,"charIndex":-1},{"text":"การจัดการอัตโนมัติ","id":"การจัดการอัตโนมัติ","depth":4,"charIndex":-1},{"text":"การเพิ่มประสิทธิภาพ","id":"การเพิ่มประสิทธิภาพ","depth":4,"charIndex":-1},{"text":"การฉีดทรัพยากร","id":"การฉีดทรัพยากร","depth":3,"charIndex":-1},{"text":"ลำดับการฉีดทรัพยากร","id":"ลำดับการฉีดทรัพยากร","depth":3,"charIndex":-1},{"text":"กระบวนการเรนเดอร์ทั้งหมด","id":"กระบวนการเรนเดอร์ทั้งหมด","depth":2,"charIndex":-1},{"text":"คุณสมบัติขั้นสูง","id":"คุณสมบัติขั้นสูง","depth":2,"charIndex":-1},{"text":"การกำหนดค่าเส้นทางพื้นฐาน","id":"การกำหนดค่าเส้นทางพื้นฐาน","depth":3,"charIndex":-1},{"text":"โหมด Import Map","id":"โหมด-import-map","depth":3,"charIndex":-1},{"text":"การกำหนดค่าฟังก์ชันเข้าสู่ระบบ","id":"การกำหนดค่าฟังก์ชันเข้าสู่ระบบ","depth":3,"charIndex":-1},{"text":"แนวทางปฏิบัติที่ดีที่สุด","id":"แนวทางปฏิบัติที่ดีที่สุด","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez เฟรมเวิร์ก กลไกหลักของการเรนเดอร์ฝั่งเซิร์ฟเวอร์","description":"อธิบายรายละเอียดเกี่ยวกับกลไก RenderContext ของ Gez เฟรมเวิร์ก ซึ่งรวมถึงการจัดการทรัพยากร การสร้าง HTML และระบบโมดูล ESM เพื่อช่วยให้นักพัฒนาทำความเข้าใจและใช้ฟีเจอร์การเรนเดอร์ฝั่งเซิร์ฟเวอร์ได้","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, การเรนเดอร์ฝั่งเซิร์ฟเวอร์, ESM, การจัดการทรัพยากร"}]]},"version":""},{"id":315,"title":"Rspack","content":"#\n\nGez ใช้ระบบสร้าง Rspack เป็นพื้นฐาน\nซึ่งใช้ประโยชน์จากความสามารถในการสร้างประสิทธิภาพสูงของ Rspack อย่างเต็มที่\nเอกสารนี้จะแนะนำตำแหน่งและฟังก์ชันหลักของ Rspack ใน Gez Framework\n\n\nคุณสมบัติ#\n\nRspack เป็นระบบสร้างหลักของ Gez Framework โดยมีคุณสมบัติสำคัญดังต่อไปนี้:\n\n * การสร้างประสิทธิภาพสูง: เครื่องมือสร้างที่พัฒนาด้วย Rust\n   ให้ความเร็วในการคอมไพล์ที่รวดเร็ว ช่วยเพิ่มความเร็วในการสร้างโปรเจกต์ขนาดใหญ่\n * การปรับปรุงประสบการณ์การพัฒนา: รองรับการอัปเดตร้อน (HMR),\n   การคอมไพล์แบบเพิ่มเติม และคุณสมบัติการพัฒนาสมัยใหม่อื่น ๆ\n   เพื่อให้ประสบการณ์การพัฒนาที่ลื่นไหล\n * การสร้างหลายสภาพแวดล้อม: การตั้งค่าการสร้างแบบรวมที่รองรับสภาพแวดล้อมไคลเอนต์\n   (client), เซิร์ฟเวอร์ (server) และ Node.js (node)\n   ทำให้กระบวนการพัฒนาหลายแพลตฟอร์มง่ายขึ้น\n * การปรับทรัพยากรให้เหมาะสม: ความสามารถในการจัดการและปรับทรัพยากรให้เหมาะสม\n   เช่น การแบ่งโค้ด, Tree Shaking, การบีบอัดทรัพยากร\n\n\nการสร้างแอปพลิเคชัน#\n\nระบบสร้าง Rspack ของ Gez ออกแบบมาแบบโมดูลาร์ โดยมีโมดูลหลักดังต่อไปนี้:\n\n\n@gez/rspack#\n\nโมดูลสร้างพื้นฐาน ให้ความสามารถหลักดังต่อไปนี้:\n\n * การตั้งค่าการสร้างแบบรวม: จัดการการตั้งค่าการสร้างมาตรฐาน\n   รองรับการตั้งค่าหลายสภาพแวดล้อม\n * การจัดการทรัพยากร: รองรับการจัดการทรัพยากร เช่น TypeScript, CSS, รูปภาพ\n * การปรับปรุงการสร้าง: ให้คุณสมบัติการปรับปรุงประสิทธิภาพ เช่น การแบ่งโค้ด,\n   Tree Shaking\n * เซิร์ฟเวอร์พัฒนา: รวมเซิร์ฟเวอร์พัฒนาประสิทธิภาพสูง รองรับ HMR\n\n\n@gez/rspack-vue#\n\nโมดูลสร้างเฉพาะสำหรับ Vue Framework ให้ความสามารถดังต่อไปนี้:\n\n * การคอมไพล์คอมโพเนนต์ Vue: รองรับการคอมไพล์คอมโพเนนต์ Vue 2/3\n   อย่างมีประสิทธิภาพ\n * การปรับปรุง SSR: การปรับปรุงเฉพาะสำหรับการเรนเดอร์ฝั่งเซิร์ฟเวอร์\n * การปรับปรุงการพัฒนา: การปรับปรุงฟังก์ชันเฉพาะสำหรับสภาพแวดล้อมการพัฒนา Vue\n\n\nกระบวนการสร้าง#\n\nกระบวนการสร้างของ Gez แบ่งออกเป็นขั้นตอนหลักดังต่อไปนี้:\n\n 1. การเริ่มต้นการตั้งค่า\n    \n    * โหลดการตั้งค่าโปรเจกต์\n    * รวมการตั้งค่าเริ่มต้นและการตั้งค่าผู้ใช้\n    * ปรับการตั้งค่าตามตัวแปรสภาพแวดล้อม\n\n 2. การคอมไพล์ทรัพยากร\n    \n    * วิเคราะห์การพึ่งพาโค้ดต้นฉบับ\n    * แปลงทรัพยากรต่าง ๆ (TypeScript, CSS เป็นต้น)\n    * จัดการการนำเข้าและส่งออกโมดูล\n\n 3. การปรับปรุง\n    \n    * ดำเนินการแบ่งโค้ด\n    * ใช้ Tree Shaking\n    * บีบอัดโค้ดและทรัพยากร\n\n 4. การสร้างผลลัพธ์\n    \n    * สร้างไฟล์เป้าหมาย\n    * ส่งออกการแมปทรัพยากร\n    * สร้างรายงานการสร้าง\n\n\nแนวปฏิบัติที่ดีที่สุด#\n\n\nการปรับปรุงสภาพแวดล้อมการพัฒนา#\n\n * การตั้งค่าการคอมไพล์แบบเพิ่มเติม: ตั้งค่าตัวเลือก cache อย่างเหมาะสม\n   เพื่อใช้ประโยชน์จากแคชในการเพิ่มความเร็วการสร้าง\n * การปรับปรุง HMR: ตั้งค่าขอบเขตการอัปเดตร้อนอย่างเหมาะสม\n   เพื่อหลีกเลี่ยงการอัปเดตโมดูลที่ไม่จำเป็น\n * การปรับปรุงการจัดการทรัพยากร: ใช้การตั้งค่า loader ที่เหมาะสม\n   เพื่อหลีกเลี่ยงการประมวลผลซ้ำ\n\n\nการปรับปรุงสภาพแวดล้อมการผลิต#\n\n * กลยุทธ์การแบ่งโค้ด: ตั้งค่า splitChunks อย่างเหมาะสม\n   เพื่อปรับปรุงการโหลดทรัพยากร\n * การบีบอัดทรัพยากร: เปิดใช้งานการตั้งค่าการบีบอัดที่เหมาะสม\n   เพื่อสร้างสมดุลระหว่างเวลาการสร้างและขนาดผลลัพธ์\n * การปรับปรุงแคช: ใช้ประโยชน์จากแฮชเนื้อหาและกลยุทธ์แคชระยะยาว\n   เพื่อเพิ่มประสิทธิภาพการโหลด\n\n\nตัวอย่างการตั้งค่า#\n\n\n\nTIP\n\nสำหรับคำอธิบาย API และตัวเลือกการตั้งค่าเพิ่มเติม โปรดดูที่ เอกสาร API Rspack","routePath":"/th/guide/essentials/rspack","lang":"th","toc":[{"text":"คุณสมบัติ","id":"คุณสมบัติ","depth":2,"charIndex":182},{"text":"การสร้างแอปพลิเคชัน","id":"การสร้างแอปพลิเคชัน","depth":2,"charIndex":882},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":978},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":1373},{"text":"กระบวนการสร้าง","id":"กระบวนการสร้าง","depth":2,"charIndex":1689},{"text":"แนวปฏิบัติที่ดีที่สุด","id":"แนวปฏิบัติที่ดีที่สุด","depth":2,"charIndex":2266},{"text":"การปรับปรุงสภาพแวดล้อมการพัฒนา","id":"การปรับปรุงสภาพแวดล้อมการพัฒนา","depth":3,"charIndex":2291},{"text":"การปรับปรุงสภาพแวดล้อมการผลิต","id":"การปรับปรุงสภาพแวดล้อมการผลิต","depth":3,"charIndex":2652},{"text":"ตัวอย่างการตั้งค่า","id":"ตัวอย่างการตั้งค่า","depth":2,"charIndex":2984}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework เครื่องมือสร้างประสิทธิภาพสูง","description":"วิเคราะห์เชิงลึกเกี่ยวกับระบบสร้าง Rspack ของ Gez Framework รวมถึงคุณสมบัติหลัก เช่น การคอมไพล์ประสิทธิภาพสูง การสร้างหลายสภาพแวดล้อม การปรับทรัพยากรให้เหมาะสม เพื่อช่วยให้นักพัฒนาสามารถสร้างเว็บแอปพลิเคชันสมัยใหม่ที่มีประสิทธิภาพและเชื่อถือได้","head":[["meta",{"property":"keywords","content":"Gez, Rspack, ระบบสร้าง, การคอมไพล์ประสิทธิภาพสูง, การอัปเดตร้อน, การสร้างหลายสภาพแวดล้อม, Tree Shaking, การแบ่งโค้ด, SSR, การปรับทรัพยากรให้เหมาะสม, ประสิทธิภาพการพัฒนา, เครื่องมือสร้าง"}]]},"version":""},{"id":316,"title":"มาตรฐาน","content":"#\n\nGez เป็นเฟรมเวิร์ก SSR ที่ทันสมัย\nใช้โครงสร้างโครงการและกลไกการแก้ไขเส้นทางที่เป็นมาตรฐาน\nเพื่อให้มั่นใจว่าการพัฒนาและการใช้งานในสภาพแวดล้อมการผลิตมีความสม่ำเสมอและบำรุงร\nักษาได้ง่าย\n\n\nมาตรฐานโครงสร้างโครงการ#\n\n\nโครงสร้างไดเรกทอรีมาตรฐาน#\n\n\n\nความรู้เพิ่มเติม\n * gez.name มาจากฟิลด์ name ใน package.json\n * dist/package.json มาจาก package.json ในไดเรกทอรีราก\n * เมื่อตั้งค่า packs.enable เป็น true จะทำการเก็บถาวรไดเรกทอรี dist\n\n\nมาตรฐานไฟล์เข้า#\n\n\nentry.client.ts#\n\nไฟล์เข้าไคลเอนต์มีหน้าที่:\n\n * เริ่มต้นแอปพลิเคชัน: กำหนดค่าพื้นฐานของแอปพลิเคชันฝั่งไคลเอนต์\n * จัดการเส้นทาง: จัดการเส้นทางและการนำทางฝั่งไคลเอนต์\n * จัดการสถานะ: จัดเก็บและอัปเดตสถานะฝั่งไคลเอนต์\n * จัดการการโต้ตอบ: จัดการเหตุการณ์ผู้ใช้และการโต้ตอบกับอินเทอร์เฟซ\n\n\nentry.server.ts#\n\nไฟล์เข้าเซิร์ฟเวอร์มีหน้าที่:\n\n * การแสดงผลฝั่งเซิร์ฟเวอร์: ดำเนินการกระบวนการ SSR\n * สร้าง HTML: สร้างโครงสร้างหน้าเริ่มต้น\n * การดึงข้อมูลล่วงหน้า: ดึงข้อมูลฝั่งเซิร์ฟเวอร์\n * การฉีดสถานะ: ส่งสถานะจากเซิร์ฟเวอร์ไปยังไคลเอนต์\n * การปรับแต่ง SEO: รับรองการปรับแต่ง SEO ของหน้า\n\n\nentry.node.ts#\n\nไฟล์เข้าเซิร์ฟเวอร์ Node.js มีหน้าที่:\n\n * กำหนดค่าเซิร์ฟเวอร์: ตั้งค่าพารามิเตอร์เซิร์ฟเวอร์ HTTP\n * จัดการเส้นทาง: จัดการกฎเส้นทางฝั่งเซิร์ฟเวอร์\n * รวม middleware: กำหนดค่า middleware ของเซิร์ฟเวอร์\n * จัดการสภาพแวดล้อม: จัดการตัวแปรสภาพแวดล้อมและการกำหนดค่า\n * การตอบสนองคำขอ: จัดการคำขอและตอบสนอง HTTP\n\n\nมาตรฐานไฟล์กำหนดค่า#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/th/guide/essentials/std","lang":"th","toc":[{"text":"มาตรฐานโครงสร้างโครงการ","id":"มาตรฐานโครงสร้างโครงการ","depth":2,"charIndex":187},{"text":"โครงสร้างไดเรกทอรีมาตรฐาน","id":"โครงสร้างไดเรกทอรีมาตรฐาน","depth":3,"charIndex":214},{"text":"มาตรฐานไฟล์เข้า","id":"มาตรฐานไฟล์เข้า","depth":2,"charIndex":431},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":450},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":737},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":1034},{"text":"มาตรฐานไฟล์กำหนดค่า","id":"มาตรฐานไฟล์กำหนดค่า","depth":2,"charIndex":1359},{"text":"package.json","id":"packagejson","depth":3,"charIndex":1382},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":1400}],"domain":"","frontmatter":{"titleSuffix":"คู่มือโครงสร้างและมาตรฐานโครงการ Gez Framework","description":"รายละเอียดโครงสร้างโครงการมาตรฐานของ Gez Framework, มาตรฐานไฟล์เข้า และมาตรฐานไฟล์กำหนดค่า เพื่อช่วยให้นักพัฒนาสร้างแอปพลิเคชัน SSR ที่เป็นมาตรฐานและบำรุงรักษาได้ง่าย","head":[["meta",{"property":"keywords","content":"Gez, โครงสร้างโครงการ, ไฟล์เข้า, มาตรฐานกำหนดค่า, SSR framework, TypeScript, มาตรฐานโครงการ, มาตรฐานการพัฒนา"}]]},"version":""},{"id":317,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/th/guide/frameworks/html","lang":"th","toc":[{"text":"โครงสร้างโปรเจกต์","id":"โครงสร้างโปรเจกต์","depth":2,"charIndex":-1},{"text":"การกำหนดค่าโปรเจกต์","id":"การกำหนดค่าโปรเจกต์","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"โครงสร้างซอร์สโค้ด","id":"โครงสร้างซอร์สโค้ด","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"การรันโปรเจกต์","id":"การรันโปรเจกต์","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"ตัวอย่างแอปพลิเคชัน HTML SSR ด้วย Gez Framework","description":"สร้างแอปพลิเคชัน HTML SSR ด้วย Gez Framework ตั้งแต่เริ่มต้น พร้อมตัวอย่างการใช้งานพื้นฐาน ตั้งแต่การเริ่มต้นโปรเจกต์ การตั้งค่า HTML และการกำหนดค่าไฟล์เข้า","head":[["meta",{"property":"keywords","content":"Gez, HTML, แอปพลิเคชัน SSR, การตั้งค่า TypeScript, การเริ่มต้นโปรเจกต์, การเรนเดอร์ฝั่งเซิร์ฟเวอร์, การโต้ตอบฝั่งไคลเอนต์"}]]},"version":""},{"id":318,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/th/guide/frameworks/preact-htm","lang":"th","toc":[{"text":"โครงสร้างโปรเจกต์","id":"โครงสร้างโปรเจกต์","depth":2,"charIndex":-1},{"text":"การกำหนดค่าโปรเจกต์","id":"การกำหนดค่าโปรเจกต์","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"โครงสร้างซอร์สโค้ด","id":"โครงสร้างซอร์สโค้ด","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"การรันโปรเจกต์","id":"การรันโปรเจกต์","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Preact+HTM SSR ตัวอย่างแอปพลิเคชัน","description":"สร้างแอปพลิเคชัน Preact+HTM SSR ที่ใช้ Gez Framework ตั้งแต่เริ่มต้น โดยแสดงตัวอย่างการใช้งานพื้นฐานของเฟรมเวิร์ก รวมถึงการเริ่มต้นโปรเจกต์ การกำหนดค่า Preact และการตั้งค่าไฟล์เข้า","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, SSR แอปพลิเคชัน, การกำหนดค่า TypeScript, การเริ่มต้นโปรเจกต์, การเรนเดอร์ฝั่งเซิร์ฟเวอร์, การโต้ตอบฝั่งไคลเอนต์"}]]},"version":""},{"id":319,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/th/guide/frameworks/vue2","lang":"th","toc":[{"text":"โครงสร้างโปรเจกต์","id":"โครงสร้างโปรเจกต์","depth":2,"charIndex":-1},{"text":"การกำหนดค่าโปรเจกต์","id":"การกำหนดค่าโปรเจกต์","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"โครงสร้างซอร์สโค้ด","id":"โครงสร้างซอร์สโค้ด","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"การรันโปรเจกต์","id":"การรันโปรเจกต์","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"ตัวอย่างแอปพลิเคชัน Vue2 SSR ด้วย Gez Framework","description":"สร้างแอปพลิเคชัน Vue2 SSR ด้วย Gez Framework ตั้งแต่เริ่มต้น พร้อมตัวอย่างการใช้งานพื้นฐาน รวมถึงการตั้งค่าโปรเจกต์ การกำหนดค่า Vue2 และการตั้งค่าไฟล์เข้า","head":[["meta",{"property":"keywords","content":"Gez, Vue2, แอปพลิเคชัน SSR, การกำหนดค่า TypeScript, การเริ่มต้นโปรเจกต์, การเรนเดอร์ฝั่งเซิร์ฟเวอร์, การโต้ตอบฝั่งไคลเอนต์"}]]},"version":""},{"id":320,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/th/guide/frameworks/vue3","lang":"th","toc":[{"text":"โครงสร้างโปรเจกต์","id":"โครงสร้างโปรเจกต์","depth":2,"charIndex":-1},{"text":"การกำหนดค่าโปรเจกต์","id":"การกำหนดค่าโปรเจกต์","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"โครงสร้างซอร์สโค้ด","id":"โครงสร้างซอร์สโค้ด","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"การรันโปรเจกต์","id":"การรันโปรเจกต์","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"ตัวอย่างแอปพลิเคชัน Vue3 SSR ด้วยเฟรมเวิร์ก Gez","description":"สร้างแอปพลิเคชัน Vue3 SSR ด้วยเฟรมเวิร์ก Gez ตั้งแต่เริ่มต้น พร้อมตัวอย่างการใช้งานพื้นฐาน ตั้งแต่การเริ่มต้นโปรเจกต์ การตั้งค่า Vue3 และการกำหนดค่าไฟล์เข้า","head":[["meta",{"property":"keywords","content":"Gez, Vue3, แอปพลิเคชัน SSR, การตั้งค่า TypeScript, การเริ่มต้นโปรเจกต์, การเรนเดอร์ฝั่งเซิร์ฟเวอร์, การโต้ตอบฝั่งไคลเอนต์, Composition API"}]]},"version":""},{"id":321,"title":"ข้อกำหนดสภาพแวดล้อม","content":"#\n\nเอกสารนี้จะอธิบายข้อกำหนดสภาพแวดล้อมที่จำเป็นสำหรับการใช้เฟรมเวิร์กนี้\nรวมถึงสภาพแวดล้อม Node.js และความเข้ากันได้ของเบราว์เซอร์\n\n\nสภาพแวดล้อม Node.js#\n\nเฟรมเวิร์กนี้ต้องการ Node.js เวอร์ชัน >= 22.6 โดยหลักเพื่อสนับสนุนการนำเข้า\nTypeScript (ผ่านแฟล็ก --experimental-strip-types)\nโดยไม่ต้องมีขั้นตอนการคอมไพล์เพิ่มเติม\n\n\nความเข้ากันได้ของเบราว์เซอร์#\n\nเฟรมเวิร์กนี้ใช้โหมดความเข้ากันได้เป็นค่าเริ่มต้นในการสร้าง\nเพื่อสนับสนุนเบราว์เซอร์ที่หลากหลายมากขึ้น อย่างไรก็ตาม\nควรทราบว่าการสนับสนุนความเข้ากันได้ของเบราว์เซอร์อย่างสมบูรณ์นั้น\nจำเป็นต้องเพิ่ม dependency es-module-shims ด้วยตนเอง\n\n\nโหมดความเข้ากันได้ (ค่าเริ่มต้น)#\n\n * 🌐 Chrome: >= 87\n * 🔷 Edge: >= 88\n * 🦊 Firefox: >= 78\n * 🧭 Safari: >= 14\n\nจากสถิติของ Can I Use การครอบคลุมเบราว์เซอร์ในโหมดความเข้ากันได้อยู่ที่ 96.81%\n\n\nโหมดสนับสนุนแบบเนทีฟ#\n\n * 🌐 Chrome: >= 89\n * 🔷 Edge: >= 89\n * 🦊 Firefox: >= 108\n * 🧭 Safari: >= 16.4\n\nโหมดสนับสนุนแบบเนทีฟมีข้อดีดังนี้:\n\n * ไม่มีค่าใช้จ่ายในการรันไทม์ ไม่จำเป็นต้องมีตัวโหลดโมดูลเพิ่มเติม\n * เบราว์เซอร์จะทำการแยกวิเคราะห์แบบเนทีฟ ทำให้การทำงานเร็วขึ้น\n * ความสามารถในการแบ่งโค้ดและโหลดตามต้องการที่ดีขึ้น\n\nจากสถิติของ Can I Use การครอบคลุมเบราว์เซอร์ในโหมดสนับสนุนแบบเนทีฟอยู่ที่ 93.5%\n\n\nการเปิดใช้งานการสนับสนุนความเข้ากันได้#\n\nข้อควรระวังสำคัญ\n\nแม้ว่าเฟรมเวิร์กนี้จะใช้โหมดความเข้ากันได้เป็นค่าเริ่มต้นในการสร้าง\nแต่เพื่อให้การสนับสนุนเบราว์เซอร์รุ่นเก่าทำงานได้อย่างสมบูรณ์ คุณจำเป็นต้องเพิ่ม\ndependency es-module-shims ในโปรเจกต์ของคุณ\n\nเพิ่มสคริปต์ต่อไปนี้ในไฟล์ HTML:\n\n\n\nวิธีปฏิบัติที่ดีที่สุด\n 1. คำแนะนำสำหรับสภาพแวดล้อมการผลิต:\n    * ควรนำ es-module-shims ไปติดตั้งบนเซิร์ฟเวอร์ของคุณเอง\n    * ตรวจสอบให้แน่ใจถึงความเสถียรและความเร็วในการโหลดทรัพยากร\n    * เพื่อหลีกเลี่ยงความเสี่ยงด้านความปลอดภัยที่อาจเกิดขึ้น\n 2. การพิจารณาด้านประสิทธิภาพ:\n    * โหมดความเข้ากันได้จะทำให้มีค่าใช้จ่ายด้านประสิทธิภาพเล็กน้อย\n    * สามารถตัดสินใจเปิดใช้งานหรือไม่โดยพิจารณาจากการกระจายตัวของเบราว์เซอร์ของผ\n      ู้ใช้เป้าหมาย","routePath":"/th/guide/start/environment","lang":"th","toc":[{"text":"สภาพแวดล้อม Node.js","id":"สภาพแวดล้อม-nodejs","depth":2,"charIndex":133},{"text":"ความเข้ากันได้ของเบราว์เซอร์","id":"ความเข้ากันได้ของเบราว์เซอร์","depth":2,"charIndex":322},{"text":"โหมดความเข้ากันได้ (ค่าเริ่มต้น)","id":"โหมดความเข้ากันได้-ค่าเริ่มต้น","depth":3,"charIndex":590},{"text":"โหมดสนับสนุนแบบเนทีฟ","id":"โหมดสนับสนุนแบบเนทีฟ","depth":3,"charIndex":786},{"text":"การเปิดใช้งานการสนับสนุนความเข้ากันได้","id":"การเปิดใช้งานการสนับสนุนความเข้ากันได้","depth":3,"charIndex":1196}],"domain":"","frontmatter":{"titleSuffix":"คู่มือความเข้ากันได้ของเฟรมเวิร์ก Gez","description":"รายละเอียดเกี่ยวกับข้อกำหนดสภาพแวดล้อมของเฟรมเวิร์ก Gez รวมถึงข้อกำหนดเวอร์ชัน Node.js และคำอธิบายความเข้ากันได้ของเบราว์เซอร์ เพื่อช่วยให้นักพัฒนาตั้งค่าสภาพแวดล้อมการพัฒนาได้อย่างถูกต้อง","head":[["meta",{"property":"keywords","content":"Gez, Node.js, ความเข้ากันได้ของเบราว์เซอร์, TypeScript, es-module-shims, การตั้งค่าสภาพแวดล้อม"}]]},"version":""},{"id":322,"title":"เริ่มต้นอย่างรวดเร็ว","content":"#\n\n\nการเริ่มต้นโปรเจกต์#\n\nสร้างและเริ่มต้นโปรเจกต์ Gez ใหม่ โดยทำตามขั้นตอนต่อไปนี้:\n\n\n\n\nการเลือกเวอร์ชันเฟรมเวิร์ก#\n\nเฟรมเวิร์ก Gez มีเวอร์ชันสแต็กเทคโนโลยีหลายเวอร์ชัน\nแต่ละเวอร์ชันได้รับการปรับให้เหมาะสมกับสถานการณ์การใช้งานที่แตกต่างกัน\nโปรดเลือกเวอร์ชันที่เหมาะสมตามความต้องการของโปรเจกต์:\n\n\nHTML#\n\nเหมาะสำหรับโปรเจกต์ที่ต้องการโครงสร้างที่เรียบง่ายที่สุด:\n\n * ไม่มี dependency ภายนอก ใช้งานได้ทันที\n * ประสบการณ์การพัฒนา JavaScript แบบดั้งเดิม\n * เหมาะสำหรับการสร้างเว็บไซต์แบบสแตติกและแอปพลิเคชันเบา\n * รองรับการขยายฟังก์ชันการทำงานแบบค่อยเป็นค่อยไป\n\nดูเอกสารเวอร์ชัน HTML อย่างละเอียด\n\n\nVue2#\n\nเหมาะสำหรับการพัฒนาแอปพลิเคชันระดับองค์กร:\n\n * รองรับ TypeScript อย่างเต็มที่\n * ระบบนิเวศของคอมโพเนนต์บุคคลที่สามที่หลากหลาย\n * เครื่องมือการพัฒนาที่ครบวงจร\n * ความเสถียรที่ผ่านการทดสอบในสภาพแวดล้อมการผลิต\n\nดูเอกสารเวอร์ชัน Vue2 อย่างละเอียด\n\n\nVue3#\n\nเหมาะสำหรับการพัฒนาเว็บแอปพลิเคชันสมัยใหม่:\n\n * ระบบ reactive ที่ใช้ Proxy\n * รองรับ Composition API\n * ประสิทธิภาพ runtime ที่ดีขึ้น\n * ขนาด bundle ที่เล็กกว่า\n\nดูเอกสารเวอร์ชัน Vue3 อย่างละเอียด\n\n\nPreact+HTM#\n\nเหมาะสำหรับโปรเจกต์ที่ต้องการความเบาและประสิทธิภาพสูง:\n\n * ขนาด runtime ที่เล็กมาก (3KB)\n * ไวยากรณ์เทมเพลต JavaScript แบบดั้งเดิม\n * API ที่เข้ากันได้กับ React\n * ประสิทธิภาพที่ยอดเยี่ยม\n\nดูเอกสารเวอร์ชัน Preact+HTM อย่างละเอียด\n\n\nการพัฒนาด้วย AI ช่วยเหลือ#\n\nเฟรมเวิร์ก Gez มีความสามารถในการพัฒนาด้วย AI ช่วยเหลือ\nซึ่งสามารถเพิ่มประสิทธิภาพการพัฒนาได้อย่างมาก:\n\n 1. เลือกเอกสารเวอร์ชันเฟรมเวิร์กที่เหมาะสม\n 2. นำเนื้อหาเอกสารไปให้ AI ช่วยเหลือ\n 3. AI จะสร้างโครงสร้างโปรเจกต์และไฟล์คอนฟิกโดยอัตโนมัติ\n\nคำแนะนำ\n\nการพัฒนาด้วย AI ช่วยเหลือไม่เพียงแต่เร่งความเร็วในการเริ่มต้นโปรเจกต์\nแต่ยังช่วยให้โครงสร้างโปรเจกต์เป็นไปตามแนวปฏิบัติที่ดีที่สุด","routePath":"/th/guide/start/getting-started","lang":"th","toc":[{"text":"การเริ่มต้นโปรเจกต์","id":"การเริ่มต้นโปรเจกต์","depth":2,"charIndex":3},{"text":"การเลือกเวอร์ชันเฟรมเวิร์ก","id":"การเลือกเวอร์ชันเฟรมเวิร์ก","depth":2,"charIndex":88},{"text":"HTML","id":"html","depth":3,"charIndex":296},{"text":"Vue2","id":"vue2","depth":3,"charIndex":594},{"text":"Vue3","id":"vue3","depth":3,"charIndex":846},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":1052},{"text":"การพัฒนาด้วย AI ช่วยเหลือ","id":"การพัฒนาด้วย-ai-ช่วยเหลือ","depth":2,"charIndex":1297}],"domain":"","frontmatter":{"titleSuffix":"คู่มือเริ่มต้นอย่างรวดเร็วของเฟรมเวิร์ก Gez","description":"คู่มือเริ่มต้นอย่างรวดเร็วของเฟรมเวิร์ก Gez ช่วยให้คุณเริ่มต้นสร้างโปรเจกต์ตั้งแต่ศูนย์ รวมถึงการเริ่มต้นโปรเจกต์ การเลือกเวอร์ชันเฟรมเวิร์ก และการพัฒนาด้วย AI ช่วยเหลือ","head":[["meta",{"name":"keywords","content":"เฟรมเวิร์ก Gez, เริ่มต้นอย่างรวดเร็ว, การเริ่มต้นโปรเจกต์, การพัฒนา Vue, การพัฒนา HTML, AI ช่วยเหลือ"}]]},"version":""},{"id":323,"title":"บทนำ","content":"#\n\n\nภูมิหลังของโครงการ#\n\nGez เป็นเฟรมเวิร์กไมโครฟรอนต์เอนด์ที่ทันสมัย โดยใช้ ECMAScript Modules (ESM)\nเป็นพื้นฐาน\nมุ่งเน้นการสร้างแอปพลิเคชันที่ให้ประสิทธิภาพสูงและขยายได้ง่ายสำหรับการเรนเดอร์ฝั\n่งเซิร์ฟเวอร์ (SSR) ในฐานะที่เป็นผลิตภัณฑ์รุ่นที่สามของโครงการ Genesis Gez\nได้มีการพัฒนาทางเทคโนโลยีอย่างต่อเนื่อง:\n\n * v1.0: ใช้การร้องขอ HTTP เพื่อโหลดคอมโพเนนต์จากระยะไกลตามต้องการ\n * v2.0: ใช้ Webpack Module Federation เพื่อการรวมแอปพลิเคชัน\n * v3.0: ออกแบบระบบการเชื่อมโยงโมดูลใหม่โดยใช้ ESM ดั้งเดิมของเบราว์เซอร์\n\n\nภูมิหลังทางเทคโนโลยี#\n\nในกระบวนการพัฒนาสถาปัตยกรรมไมโครฟรอนต์เอนด์\nโซลูชันแบบดั้งเดิมมีข้อจำกัดหลักดังต่อไปนี้:\n\n\nความท้าทายของโซลูชันที่มีอยู่#\n\n * ปัญหาด้านประสิทธิภาพ: การฉีดการพึ่งพาในเวลารันและการใช้พร็อกซีแซนด์บ็อกซ์ของ\n   JavaScript ส่งผลให้เกิดค่าใช้จ่ายด้านประสิทธิภาพที่สำคัญ\n * กลไกการแยกส่วน:\n   สภาพแวดล้อมแซนด์บ็อกซ์ที่พัฒนาขึ้นเองยากที่จะเทียบเคียงกับความสามารถในการแยกโ\n   มดูลดั้งเดิมของเบราว์เซอร์\n * ความซับซ้อนในการสร้าง:\n   การปรับเปลี่ยนเครื่องมือสร้างเพื่อให้สามารถแบ่งปันการพึ่งพาได้\n   ทำให้ต้นทุนการบำรุงรักษาโครงการเพิ่มขึ้น\n * การเบี่ยงเบนจากมาตรฐาน: กลยุทธ์การปรับใช้และการจัดการในเวลารันที่พิเศษ\n   ทำให้ไม่สอดคล้องกับมาตรฐานการพัฒนาเว็บสมัยใหม่\n * ข้อจำกัดของระบบนิเวศ: การผูกติดกับเฟรมเวิร์กและ API ที่กำหนดเอง\n   ทำให้การเลือกสแต็กเทคโนโลยีถูกจำกัด\n\n\nนวัตกรรมทางเทคโนโลยี#\n\nGez ได้นำเสนอโซลูชันใหม่โดยใช้มาตรฐานเว็บสมัยใหม่:\n\n * ระบบโมดูลดั้งเดิม: ใช้ ESM ดั้งเดิมของเบราว์เซอร์และ Import Maps\n   เพื่อจัดการการพึ่งพา ทำให้การแยกวิเคราะห์และการทำงานเร็วขึ้น\n * กลไกการแยกส่วนมาตรฐาน: ใช้ขอบเขตโมดูลของ ECMAScript\n   เพื่อสร้างการแยกแอปพลิเคชันที่เชื่อถือได้\n * สแต็กเทคโนโลยีที่เปิดกว้าง:\n   รองรับการเชื่อมต่อกับเฟรมเวิร์กฟรอนต์เอนด์สมัยใหม่ใดๆ ได้อย่างราบรื่น\n * การปรับปรุงประสบการณ์การพัฒนา:\n   ให้รูปแบบการพัฒนาที่เป็นไปตามสัญชาตญาณและความสามารถในการดีบักที่สมบูรณ์\n * การปรับปรุงประสิทธิภาพสูงสุด:\n   ใช้ความสามารถดั้งเดิมเพื่อให้ไม่มีค่าใช้จ่ายในเวลารัน\n   พร้อมกับกลยุทธ์การแคชที่ชาญฉลาด\n\nTIP\n\nGez\nมุ่งเน้นการสร้างโครงสร้างพื้นฐานไมโครฟรอนต์เอนด์ที่ให้ประสิทธิภาพสูงและขยายได้ง่\nาย โดยเฉพาะอย่างยิ่งเหมาะสำหรับแอปพลิเคชันการเรนเดอร์ฝั่งเซิร์ฟเวอร์ขนาดใหญ่\n\n\nมาตรฐานทางเทคโนโลยี#\n\n\nการพึ่งพาสภาพแวดล้อม#\n\nโปรดดูเอกสารข้อกำหนดสภาพแวดล้อมเพื่อทราบข้อกำหนดเบราว์เซอร์และ Node.js\nที่ละเอียด\n\n\nสแต็กเทคโนโลยีหลัก#\n\n * การจัดการการพึ่งพา: ใช้ Import Maps เพื่อทำการแมปโมดูล และใช้ es-module-shims\n   เพื่อให้การรองรับที่เข้ากันได้\n * ระบบการสร้าง: ใช้ module-import ของ Rspack เพื่อจัดการการพึ่งพาภายนอก\n * เครื่องมือการพัฒนา: รองรับการอัปเดตแบบร้อนของ ESM และการทำงานดั้งเดิมของ\n   TypeScript\n\n\nตำแหน่งของเฟรมเวิร์ก#\n\nGez แตกต่างจาก Next.js หรือ Nuxt.js\nโดยมุ่งเน้นการให้โครงสร้างพื้นฐานไมโครฟรอนต์เอนด์:\n\n * ระบบการเชื่อมโยงโมดูล:\n   ทำให้การนำเข้าและส่งออกโมดูลมีประสิทธิภาพและเชื่อถือได้\n * การเรนเดอร์ฝั่งเซิร์ฟเวอร์: ให้กลไกการเรนเดอร์ SSR ที่ยืดหยุ่น\n * การรองรับระบบประเภท: รวมการกำหนดประเภท TypeScript ที่สมบูรณ์\n * ความเป็นกลางของเฟรมเวิร์ก: รองรับการรวมกับเฟรมเวิร์กฟรอนต์เอนด์หลัก\n\n\nการออกแบบสถาปัตยกรรม#\n\n\nการจัดการการพึ่งพาแบบรวมศูนย์#\n\n * แหล่งการพึ่งพาแบบรวมศูนย์: การจัดการการพึ่งพาบุคคลที่สามแบบรวมศูนย์\n * การกระจายอัตโนมัติ: การอัปเดตการพึ่งพาจะถูกซิงค์ทั่วโลกโดยอัตโนมัติ\n * ความสอดคล้องของเวอร์ชัน: การควบคุมเวอร์ชันการพึ่งพาที่แม่นยำ\n\n\nการออกแบบโมดูลาร์#\n\n * การแยกหน้าที่: แยกตรรกะทางธุรกิจออกจากโครงสร้างพื้นฐาน\n * กลไกปลั๊กอิน: รองรับการรวมและการแทนที่โมดูลที่ยืดหยุ่น\n * อินเทอร์เฟซมาตรฐาน: โปรโตคอลการสื่อสารระหว่างโมดูลที่เป็นมาตรฐาน\n\n\nการปรับปรุงประสิทธิภาพ#\n\n * หลักการไม่มีค่าใช้จ่าย:\n   ใช้ความสามารถดั้งเดิมของเบราว์เซอร์ให้เกิดประโยชน์สูงสุด\n * การแคชที่ชาญฉลาด: กลยุทธ์การแคชที่แม่นยำโดยใช้แฮชเนื้อหา\n * การโหลดตามต้องการ: การแบ่งโค้ดและการจัดการการพึ่งพาที่ละเอียด\n\n\nความสมบูรณ์ของโครงการ#\n\nGez ได้ผ่านการพัฒนามาเกือบ 5 ปี (ตั้งแต่ v1.0 ถึง v3.0)\nและได้รับการทดสอบอย่างเต็มที่ในสภาพแวดล้อมระดับองค์กร\nปัจจุบันรองรับการทำงานที่มั่นคงของโครงการธุรกิจหลายสิบโครงการ\nและยังคงผลักดันให้มีการอัปเกรดสแต็กเทคโนโลยีให้ทันสมัย ความเสถียร\nความน่าเชื่อถือ\nและข้อได้เปรียบด้านประสิทธิภาพของเฟรมเวิร์กได้รับการพิสูจน์แล้วในทางปฏิบัติ\nทำให้เป็นพื้นฐานทางเทคโนโลยีที่เชื่อถือได้สำหรับการพัฒนาแอปพลิเคชันขนาดใหญ่","routePath":"/th/guide/start/introduction","lang":"th","toc":[{"text":"ภูมิหลังของโครงการ","id":"ภูมิหลังของโครงการ","depth":2,"charIndex":3},{"text":"ภูมิหลังทางเทคโนโลยี","id":"ภูมิหลังทางเทคโนโลยี","depth":2,"charIndex":516},{"text":"ความท้าทายของโซลูชันที่มีอยู่","id":"ความท้าทายของโซลูชันที่มีอยู่","depth":3,"charIndex":630},{"text":"นวัตกรรมทางเทคโนโลยี","id":"นวัตกรรมทางเทคโนโลยี","depth":3,"charIndex":1300},{"text":"มาตรฐานทางเทคโนโลยี","id":"มาตรฐานทางเทคโนโลยี","depth":2,"charIndex":2115},{"text":"การพึ่งพาสภาพแวดล้อม","id":"การพึ่งพาสภาพแวดล้อม","depth":3,"charIndex":2138},{"text":"สแต็กเทคโนโลยีหลัก","id":"สแต็กเทคโนโลยีหลัก","depth":3,"charIndex":2245},{"text":"ตำแหน่งของเฟรมเวิร์ก","id":"ตำแหน่งของเฟรมเวิร์ก","depth":2,"charIndex":2546},{"text":"การออกแบบสถาปัตยกรรม","id":"การออกแบบสถาปัตยกรรม","depth":2,"charIndex":2945},{"text":"การจัดการการพึ่งพาแบบรวมศูนย์","id":"การจัดการการพึ่งพาแบบรวมศูนย์","depth":3,"charIndex":2969},{"text":"การออกแบบโมดูลาร์","id":"การออกแบบโมดูลาร์","depth":3,"charIndex":3209},{"text":"การปรับปรุงประสิทธิภาพ","id":"การปรับปรุงประสิทธิภาพ","depth":3,"charIndex":3415},{"text":"ความสมบูรณ์ของโครงการ","id":"ความสมบูรณ์ของโครงการ","depth":2,"charIndex":3654}],"domain":"","frontmatter":{"titleSuffix":"ภาพรวมของเฟรมเวิร์ก Gez และนวัตกรรมทางเทคโนโลยี","description":"เรียนรู้เพิ่มเติมเกี่ยวกับภูมิหลังของโครงการ เทคโนโลยีที่พัฒนา และข้อได้เปรียบหลักของเฟรมเวิร์ก Gez สำหรับไมโครฟรอนต์เอนด์ พร้อมสำรวจโซลูชันการเรนเดอร์ฝั่งเซิร์ฟเวอร์ที่ทันสมัยโดยใช้ ESM","head":[["meta",{"property":"keywords","content":"Gez, ไมโครฟรอนต์เอนด์, ESM, การเรนเดอร์ฝั่งเซิร์ฟเวอร์, SSR, นวัตกรรมทางเทคโนโลยี, Module Federation"}]]},"version":""}]