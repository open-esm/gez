"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["1318"],{42698:function(e,a,n){n.r(a),n.d(a,{default:()=>d});var i=n(31549),r=n(6603);function o(e){let a=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",ul:"ul",li:"li",strong:"strong",ol:"ol"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(a.h1,{id:"od-wsp\\xf3łdzielenia-komponent\\xf3w-do-natywnej-modularności-droga-ewolucji-frameworka-mikrofrontend\\xf3w-gez",children:["Od wsp\xf3łdzielenia komponent\xf3w do natywnej modularności: Droga ewolucji frameworka mikrofrontend\xf3w Gez",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#od-wsp\\xf3łdzielenia-komponent\\xf3w-do-natywnej-modularności-droga-ewolucji-frameworka-mikrofrontend\\xf3w-gez",children:"#"})]}),"\n",(0,i.jsxs)(a.h2,{id:"tło-projektu",children:["Tło projektu",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#tło-projektu",children:"#"})]}),"\n",(0,i.jsx)(a.p,{children:"W ciągu ostatnich kilku lat architektura mikrofrontend\xf3w szukała właściwej drogi. Jednak obserwowaliśmy r\xf3żne skomplikowane rozwiązania techniczne, kt\xf3re poprzez warstwy opakowań i sztuczną izolację pr\xf3bowały symulować idealny świat mikrofrontend\xf3w. Te rozwiązania przyniosły znaczące obciążenie wydajnościowe, komplikując prosty rozw\xf3j i zaciemniając standardowe procesy."}),"\n",(0,i.jsxs)(a.h3,{id:"ograniczenia-tradycyjnych-rozwiązań",children:["Ograniczenia tradycyjnych rozwiązań",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#ograniczenia-tradycyjnych-rozwiązań",children:"#"})]}),"\n",(0,i.jsx)(a.p,{children:"W praktyce architektury mikrofrontend\xf3w doświadczyliśmy wielu ograniczeń tradycyjnych rozwiązań:"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Straty wydajności"}),": Wstrzykiwanie zależności w czasie wykonywania, proxy piaskownicy JS, każda operacja pochłania cenną wydajność"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Krucha izolacja"}),": Sztucznie stworzone środowisko piaskownicy nigdy nie dor\xf3wna natywnej izolacji przeglądarki"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Złożoność budowania"}),": Aby poradzić sobie z zależnościami, konieczne było modyfikowanie narzędzi budujących, co utrudniało utrzymanie prostych projekt\xf3w"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Niestandardowe reguły"}),": Specjalne strategie wdrażania, przetwarzanie w czasie wykonywania, każdy krok odbiegał od standardowych proces\xf3w wsp\xf3łczesnego rozwoju"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Ograniczenia ekosystemu"}),": Powiązanie z frameworkiem, niestandardowe API, co zmuszało do wiązania się z określonym ekosystemem"]}),"\n"]}),"\n",(0,i.jsx)(a.p,{children:"Te problemy były szczeg\xf3lnie widoczne w naszym projekcie korporacyjnym z 2019 roku. W\xf3wczas duży produkt został podzielony na kilkanaście niezależnych podsystem\xf3w biznesowych, kt\xf3re musiały wsp\xf3łdzielić zestaw podstawowych i biznesowych komponent\xf3w. Początkowo zastosowane rozwiązanie wsp\xf3łdzielenia komponent\xf3w oparte na pakietach npm ujawniło poważne problemy z efektywnością utrzymania: gdy wsp\xf3łdzielony komponent był aktualizowany, wszystkie podsystemy zależne od tego komponentu musiały przejść pełny proces budowania i wdrażania."}),"\n",(0,i.jsxs)(a.h2,{id:"ewolucja-technologiczna",children:["Ewolucja technologiczna",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#ewolucja-technologiczna",children:"#"})]}),"\n",(0,i.jsxs)(a.h3,{id:"v10-eksploracja-zdalnych-komponent\\xf3w",children:["v1.0: Eksploracja zdalnych komponent\xf3w",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#v10-eksploracja-zdalnych-komponent\\xf3w",children:"#"})]}),"\n",(0,i.jsx)(a.p,{children:"Aby rozwiązać problem efektywności wsp\xf3łdzielenia komponent\xf3w, Gez v1.0 wprowadził mechanizm komponent\xf3w RemoteView oparty na protokole HTTP. To rozwiązanie, poprzez dynamiczne żądania w czasie wykonywania, umożliwiło składanie kodu między usługami na żądanie, skutecznie rozwiązując problem zbyt długiego łańcucha zależności budowania. Jednak ze względu na brak standaryzowanego mechanizmu komunikacji w czasie wykonywania, synchronizacja stanu i przekazywanie zdarzeń między usługami nadal miały wąskie gardła wydajnościowe."}),"\n",(0,i.jsxs)(a.h3,{id:"v20-pr\\xf3ba-federacji-moduł\\xf3w",children:["v2.0: Pr\xf3ba federacji moduł\xf3w",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#v20-pr\\xf3ba-federacji-moduł\\xf3w",children:"#"})]}),"\n",(0,i.jsxs)(a.p,{children:["W wersji v2.0 zastosowaliśmy technologię ",(0,i.jsx)(a.a,{href:"https://webpack.js.org/concepts/module-federation/",target:"_blank",rel:"noopener noreferrer",children:"federacji moduł\xf3w (Module Federation)"})," z ",(0,i.jsx)(a.a,{href:"https://webpack.js.org/",target:"_blank",rel:"noopener noreferrer",children:"Webpack 5.0"}),". Ta technologia, poprzez ujednolicony mechanizm ładowania moduł\xf3w i kontenery w czasie wykonywania, znacząco poprawiła efektywność wsp\xf3łpracy między usługami. Jednak w praktyce na dużą skalę, zamknięty mechanizm implementacji federacji moduł\xf3w przyni\xf3sł nowe wyzwania: trudności w precyzyjnym zarządzaniu wersjami zależności, szczeg\xf3lnie przy ujednolicaniu wsp\xf3łdzielonych zależności wielu usług, często napotykaliśmy konflikty wersji i wyjątki w czasie wykonywania."]}),"\n",(0,i.jsxs)(a.h2,{id:"wkraczanie-w-nową-erę-esm",children:["Wkraczanie w nową erę ESM",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#wkraczanie-w-nową-erę-esm",children:"#"})]}),"\n",(0,i.jsx)(a.p,{children:"Planując wersję v3.0, dokładnie obserwowaliśmy trendy rozwoju ekosystemu frontendu i zauważyliśmy, że postęp w natywnych możliwościach przeglądarek otworzył nowe możliwości dla architektury mikrofrontend\xf3w:"}),"\n",(0,i.jsxs)(a.h3,{id:"standaryzowany-system-moduł\\xf3w",children:["Standaryzowany system moduł\xf3w",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#standaryzowany-system-moduł\\xf3w",children:"#"})]}),"\n",(0,i.jsxs)(a.p,{children:["Wraz z pełnym wsparciem gł\xf3wnych przeglądarek dla ",(0,i.jsx)(a.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",target:"_blank",rel:"noopener noreferrer",children:"ES Modules"})," oraz dojrzałością specyfikacji ",(0,i.jsx)(a.a,{href:"https://github.com/WICG/import-maps",target:"_blank",rel:"noopener noreferrer",children:"Import Maps"}),", rozw\xf3j frontendu wkroczył w prawdziwą erę modularności. Według statystyk ",(0,i.jsx)(a.a,{href:"https://caniuse.com/?search=importmap",target:"_blank",rel:"noopener noreferrer",children:"Can I Use"}),", obecnie gł\xf3wne przeglądarki (Chrome >= 89, Edge >= 89, Firefox >= 108, Safari >= 16.4) osiągnęły 93.5% natywnego wsparcia dla ESM, co zapewnia nam następujące korzyści:"]}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Standaryzacja zarządzania zależnościami"}),": Import Maps zapewnia możliwość rozwiązywania zależności moduł\xf3w na poziomie przeglądarki, bez potrzeby skomplikowanego wstrzykiwania w czasie wykonywania"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Optymalizacja ładowania zasob\xf3w"}),": Natywny mechanizm buforowania moduł\xf3w w przeglądarce znacząco poprawia efektywność ładowania zasob\xf3w"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Uproszczenie procesu budowania"}),": Tryb rozwoju oparty na ESM sprawia, że procesy budowania środowisk deweloperskich i produkcyjnych są bardziej sp\xf3jne"]}),"\n"]}),"\n",(0,i.jsx)(a.p,{children:"Jednocześnie, dzięki wsparciu trybu kompatybilności (Chrome >= 87, Edge >= 88, Firefox >= 78, Safari >= 14), możemy zwiększyć zasięg przeglądarek do 96.81%, co pozwala nam zachować wysoką wydajność bez rezygnacji z wsparcia dla starszych przeglądarek."}),"\n",(0,i.jsxs)(a.h3,{id:"przełom-w-wydajności-i-izolacji",children:["Przełom w wydajności i izolacji",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#przełom-w-wydajności-i-izolacji",children:"#"})]}),"\n",(0,i.jsx)(a.p,{children:"Natywny system moduł\xf3w przyni\xf3sł nie tylko standaryzację, ale także znaczącą poprawę wydajności i izolacji:"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Zero narzutu w czasie wykonywania"}),": Pożegnanie z proxy piaskownicy JavaScript i wstrzykiwaniem w czasie wykonywania w tradycyjnych rozwiązaniach mikrofrontend\xf3w"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Niezawodny mechanizm izolacji"}),": Ścisły zakres moduł\xf3w ESM naturalnie zapewnia najbardziej niezawodną izolację"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Precyzyjne zarządzanie zależnościami"}),": Statyczna analiza importu sprawia, że zależności są bardziej przejrzyste, a kontrola wersji bardziej precyzyjna"]}),"\n"]}),"\n",(0,i.jsxs)(a.h3,{id:"wyb\\xf3r-narzędzi-budujących",children:["Wyb\xf3r narzędzi budujących",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#wyb\\xf3r-narzędzi-budujących",children:"#"})]}),"\n",(0,i.jsx)(a.p,{children:"W procesie wdrażania rozwiązania technologicznego, wyb\xf3r narzędzi budujących był kluczową decyzją. Po prawie rocznych badaniach i praktyce, nasz wyb\xf3r przeszedł następującą ewolucję:"}),"\n",(0,i.jsxs)(a.ol,{children:["\n",(0,i.jsxs)(a.li,{children:["\n",(0,i.jsx)(a.p,{children:(0,i.jsx)(a.strong,{children:"Eksploracja Vite"})}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsx)(a.li,{children:"Zalety: Serwer deweloperski oparty na ESM, zapewniający doskonałe doświadczenie deweloperskie"}),"\n",(0,i.jsx)(a.li,{children:"Wyzwania: R\xf3żnice w budowaniu środowisk deweloperskich i produkcyjnych wprowadzały pewną niepewność"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(a.li,{children:["\n",(0,i.jsx)(a.p,{children:(0,i.jsxs)(a.strong,{children:["Ustalenie ",(0,i.jsx)(a.a,{href:"https://www.rspack.dev/",target:"_blank",rel:"noopener noreferrer",children:"Rspack"})]})}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:["Zalety wydajnościowe: Wysokowydajna kompilacja oparta na ",(0,i.jsx)(a.a,{href:"https://www.rust-lang.org/",target:"_blank",rel:"noopener noreferrer",children:"Rust"}),", znacząco poprawiająca szybkość budowania"]}),"\n",(0,i.jsx)(a.li,{children:"Wsparcie ekosystemu: Wysoka kompatybilność z ekosystemem Webpack, obniżająca koszty migracji"}),"\n",(0,i.jsx)(a.li,{children:"Wsparcie ESM: Praktyka projektu Rslib potwierdziła niezawodność w budowaniu ESM"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(a.p,{children:"Ta decyzja pozwoliła nam zachować doświadczenie deweloperskie, jednocześnie zapewniając bardziej stabilne wsparcie dla środowiska produkcyjnego. Dzięki kombinacji ESM i Rspack, ostatecznie zbudowaliśmy wysokowydajne, mało inwazyjne rozwiązanie mikrofrontend\xf3w."}),"\n",(0,i.jsxs)(a.h2,{id:"perspektywy-na-przyszłość",children:["Perspektywy na przyszłość",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#perspektywy-na-przyszłość",children:"#"})]}),"\n",(0,i.jsx)(a.p,{children:"W przyszłych planach rozwoju framework Gez skupi się na następujących trzech kierunkach:"}),"\n",(0,i.jsxs)(a.h3,{id:"głęboka-optymalizacja-import-maps",children:["Głęboka optymalizacja Import Maps",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#głęboka-optymalizacja-import-maps",children:"#"})]}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Dynamiczne zarządzanie zależnościami"}),": Inteligentne planowanie wersji zależności w czasie wykonywania, rozwiązujące konflikty zależności między wieloma aplikacjami"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Strategie preładowania"}),": Inteligentne preładowanie oparte na analizie routingu, poprawiające efektywność ładowania zasob\xf3w"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Optymalizacja budowania"}),": Automatyczne generowanie optymalnej konfiguracji Import Maps, redukujące koszty ręcznej konfiguracji przez deweloper\xf3w"]}),"\n"]}),"\n",(0,i.jsxs)(a.h3,{id:"niezależne-od-frameworka-rozwiązanie-routingu",children:["Niezależne od frameworka rozwiązanie routingu",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#niezależne-od-frameworka-rozwiązanie-routingu",children:"#"})]}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Abstrakcja ujednoliconego routingu"}),": Projektowanie interfejs\xf3w routingu niezależnych od frameworka, wspierających gł\xf3wne frameworki takie jak Vue, React"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Routing mikroaplikacji"}),": Implementacja powiązań routingu między aplikacjami, utrzymująca sp\xf3jność URL i stanu aplikacji"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Middleware routingu"}),": Zapewnienie rozszerzalnego mechanizmu middleware, wspierającego kontrolę dostępu, przejścia między stronami itp."]}),"\n"]}),"\n",(0,i.jsxs)(a.h3,{id:"najlepsze-praktyki-komunikacji-między-frameworkami",children:["Najlepsze praktyki komunikacji między frameworkami",(0,i.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#najlepsze-praktyki-komunikacji-między-frameworkami",children:"#"})]}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Przykładowe aplikacje"}),": Dostarczenie kompletnych przykład\xf3w komunikacji między frameworkami, obejmujących gł\xf3wne frameworki takie jak Vue, React, Preact"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Synchronizacja stanu"}),": Lekkie rozwiązanie wsp\xf3łdzielenia stanu oparte na ESM"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Szyna zdarzeń"}),": Standaryzowany mechanizm komunikacji zdarzeń, wspierający odłączoną komunikację między aplikacjami"]}),"\n"]}),"\n",(0,i.jsx)(a.p,{children:"Dzięki tym optymalizacjom i rozszerzeniom, oczekujemy, że Gez stanie się bardziej kompletnym i łatwym w użyciu rozwiązaniem mikrofrontend\xf3w, zapewniającym deweloperom lepsze doświadczenie i wyższą efektywność rozwoju."})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:a}=Object.assign({},(0,r.ah)(),e.components);return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["pl%2Fblog%2Fbirth-of-gez.md"]={toc:[{text:"Tło projektu",id:"tło-projektu",depth:2},{text:"Ograniczenia tradycyjnych rozwiązań",id:"ograniczenia-tradycyjnych-rozwiązań",depth:3},{text:"Ewolucja technologiczna",id:"ewolucja-technologiczna",depth:2},{text:"v1.0: Eksploracja zdalnych komponent\xf3w",id:"v10-eksploracja-zdalnych-komponent\xf3w",depth:3},{text:"v2.0: Pr\xf3ba federacji moduł\xf3w",id:"v20-pr\xf3ba-federacji-moduł\xf3w",depth:3},{text:"Wkraczanie w nową erę ESM",id:"wkraczanie-w-nową-erę-esm",depth:2},{text:"Standaryzowany system moduł\xf3w",id:"standaryzowany-system-moduł\xf3w",depth:3},{text:"Przełom w wydajności i izolacji",id:"przełom-w-wydajności-i-izolacji",depth:3},{text:"Wyb\xf3r narzędzi budujących",id:"wyb\xf3r-narzędzi-budujących",depth:3},{text:"Perspektywy na przyszłość",id:"perspektywy-na-przyszłość",depth:2},{text:"Głęboka optymalizacja Import Maps",id:"głęboka-optymalizacja-import-maps",depth:3},{text:"Niezależne od frameworka rozwiązanie routingu",id:"niezależne-od-frameworka-rozwiązanie-routingu",depth:3},{text:"Najlepsze praktyki komunikacji między frameworkami",id:"najlepsze-praktyki-komunikacji-między-frameworkami",depth:3}],title:"Od wsp\xf3łdzielenia komponent\xf3w do natywnej modularności: Droga ewolucji frameworka mikrofrontend\xf3w Gez",headingTitle:"Od wsp\xf3łdzielenia komponent\xf3w do natywnej modularności: Droga ewolucji frameworka mikrofrontend\xf3w Gez",frontmatter:{titleSuffix:"Od wyzwań mikrofrontend\xf3w do innowacji ESM: Droga ewolucji frameworka Gez",description:"Głęboka analiza ewolucji frameworka Gez od tradycyjnych architektur mikrofrontend\xf3w do innowacji opartych na ESM, dzielenie się praktycznymi doświadczeniami w optymalizacji wydajności, zarządzaniu zależnościami i wyborze narzędzi budujących.",head:[["meta",{property:"keywords",content:"Gez, framework mikrofrontend\xf3w, ESM, Import Maps, Rspack, federacja moduł\xf3w, zarządzanie zależnościami, optymalizacja wydajności, ewolucja technologiczna, renderowanie po stronie serwera"}]],sidebar:!1}}}}]);