"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["1880"],{99642:function(e,n,r){r.r(n),r.d(n,{default:()=>h});var i=r(31549),s=r(6603);function d(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",ul:"ul",li:"li",strong:"strong",ol:"ol"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"จากส่วนประกอบที่ใช้ร่วมกันสู่โมดูลแบบเนทีฟ-เส้นทางวิวัฒนาการของเฟรมเวิร์กไมโครฟรอนต์เอนด์-gez",children:["จากส่วนประกอบที่ใช้ร่วมกันสู่โมดูลแบบเนทีฟ: เส้นทางวิวัฒนาการของเฟรมเวิร์กไมโครฟรอนต์เอนด์ Gez",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#จากส่วนประกอบที่ใช้ร่วมกันสู่โมดูลแบบเนทีฟ-เส้นทางวิวัฒนาการของเฟรมเวิร์กไมโครฟรอนต์เอนด์-gez",children:"#"})]}),"\n",(0,i.jsxs)(n.h2,{id:"ภูมิหลังของโครงการ",children:["ภูมิหลังของโครงการ",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ภูมิหลังของโครงการ",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"ในช่วงหลายปีที่ผ่านมา สถาปัตยกรรมไมโครฟรอนต์เอนด์ได้พยายามหาทางที่ถูกต้อง อย่างไรก็ตาม สิ่งที่เราเห็นคือโซลูชันทางเทคนิคที่ซับซ้อนต่างๆ ที่ใช้การห่อหุ้มและการแยกส่วนด้วยมือเพื่อจำลองโลกของไมโครฟรอนต์เอนด์ในอุดมคติ โซลูชันเหล่านี้ได้นำมาซึ่งภาระด้านประสิทธิภาพที่หนักหน่วง ทำให้การพัฒนาที่เรียบง่ายกลายเป็นเรื่องซับซ้อน และทำให้กระบวนการมาตรฐานกลายเป็นเรื่องที่เข้าใจยาก"}),"\n",(0,i.jsxs)(n.h3,{id:"ข้อจำกัดของโซลูชันแบบดั้งเดิม",children:["ข้อจำกัดของโซลูชันแบบดั้งเดิม",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ข้อจำกัดของโซลูชันแบบดั้งเดิม",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"ในการปฏิบัติตามสถาปัตยกรรมไมโครฟรอนต์เอนด์ เราได้สัมผัสกับข้อจำกัดมากมายของโซลูชันแบบดั้งเดิม:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"การสูญเสียประสิทธิภาพ"}),": การ inject dependencies ใน runtime, การใช้ JavaScript sandbox proxy ทุกการดำเนินการล้วนแต่ใช้ทรัพยากรประสิทธิภาพที่มีค่า"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"การแยกส่วนที่เปราะบาง"}),": สภาพแวดล้อม sandbox ที่สร้างขึ้นด้วยมือ ไม่สามารถเทียบเคียงกับความสามารถในการแยกส่วนแบบเนทีฟของเบราว์เซอร์ได้"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ความซับซ้อนในการ build"}),": เพื่อจัดการกับความสัมพันธ์ของ dependencies จำเป็นต้องปรับแต่งเครื่องมือ build ทำให้โครงการที่เรียบง่ายกลายเป็นเรื่องที่ดูแลรักษายาก"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"กฎที่ปรับแต่งเอง"}),": กลยุทธ์การ deploy ที่พิเศษ การประมวลผลใน runtime ทำให้ทุกขั้นตอนเบี่ยงเบนไปจากกระบวนการพัฒนามาตรฐานสมัยใหม่"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ข้อจำกัดของ ecosystem"}),": การผูกมัดกับเฟรมเวิร์ก, API ที่ปรับแต่งเอง ทำให้การเลือกเทคโนโลยีถูกผูกมัดกับ ecosystem เฉพาะ"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"ปัญหาเหล่านี้ปรากฏชัดเจนในโครงการระดับองค์กรของเราในปี 2019 ในเวลานั้น ผลิตภัณฑ์ขนาดใหญ่ถูกแบ่งออกเป็นระบบย่อยทางธุรกิจอิสระกว่า 10 ระบบ ซึ่งระบบย่อยเหล่านี้จำเป็นต้องใช้ชุดคอมโพเนนต์พื้นฐานและคอมโพเนนต์ทางธุรกิจร่วมกัน โซลูชันการแชร์คอมโพเนนต์ที่ใช้ npm package ในตอนแรกได้เผยให้เห็นปัญหาด้านประสิทธิภาพในการบำรุงรักษาอย่างรุนแรง: เมื่อคอมโพเนนต์ที่แชร์มีการอัปเดต ระบบย่อยทั้งหมดที่พึ่งพาคอมโพเนนต์นี้จำเป็นต้องผ่านกระบวนการ build และ deploy ที่สมบูรณ์"}),"\n",(0,i.jsxs)(n.h2,{id:"การพัฒนาทางเทคนิค",children:["การพัฒนาทางเทคนิค",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#การพัฒนาทางเทคนิค",children:"#"})]}),"\n",(0,i.jsxs)(n.h3,{id:"v10-การสำรวจ-remote-component",children:["v1.0: การสำรวจ Remote Component",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#v10-การสำรวจ-remote-component",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"เพื่อแก้ปัญหาประสิทธิภาพในการแชร์คอมโพเนนต์ Gez v1.0 ได้แนะนำกลไก RemoteView component ที่ใช้โปรโตคอล HTTP โซลูชันนี้ได้แก้ปัญหาห่วงโซ่ dependencies ที่ยาวเกินไปในการ build ผ่านการร้องขอโค้ดแบบไดนามิกใน runtime อย่างไรก็ตาม เนื่องจากขาดกลไกการสื่อสารใน runtime ที่เป็นมาตรฐาน การซิงโครไนซ์สถานะและการส่งผ่านเหตุการณ์ระหว่างเซอร์วิสยังคงมีปัญหาด้านประสิทธิภาพ"}),"\n",(0,i.jsxs)(n.h3,{id:"v20-การทดลอง-module-federation",children:["v2.0: การทดลอง Module Federation",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#v20-การทดลอง-module-federation",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["ในเวอร์ชัน v2.0 เราได้ใช้เทคโนโลยี ",(0,i.jsx)(n.a,{href:"https://webpack.js.org/concepts/module-federation/",target:"_blank",rel:"noopener noreferrer",children:"Module Federation"})," ของ ",(0,i.jsx)(n.a,{href:"https://webpack.js.org/",target:"_blank",rel:"noopener noreferrer",children:"Webpack 5.0"})," เทคโนโลยีนี้ได้ปรับปรุงประสิทธิภาพการทำงานร่วมกันระหว่างเซอร์วิสอย่างมีนัยสำคัญผ่านกลไกการโหลดโมดูลที่รวมเป็นหนึ่งเดียวและคอนเทนเนอร์ใน runtime อย่างไรก็ตาม ในการปฏิบัติจริงในวงกว้าง การใช้งาน Module Federation แบบปิดได้นำมาซึ่งความท้าทายใหม่: การจัดการเวอร์ชัน dependencies ที่แม่นยำเป็นเรื่องยาก โดยเฉพาะอย่างยิ่งเมื่อต้องการรวม dependencies ที่แชร์กันระหว่างหลายเซอร์วิส มักจะพบปัญหาความขัดแย้งของเวอร์ชันและข้อผิดพลาดใน runtime"]}),"\n",(0,i.jsxs)(n.h2,{id:"การก้าวสู่ยุคใหม่ของ-esm",children:["การก้าวสู่ยุคใหม่ของ ESM",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#การก้าวสู่ยุคใหม่ของ-esm",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"ในการวางแผนเวอร์ชัน v3.0 เราได้สังเกตแนวโน้มการพัฒนา ecosystem ด้าน frontend อย่างลึกซึ้ง และพบว่าความก้าวหน้าของความสามารถแบบเนทีฟของเบราว์เซอร์ได้นำมาซึ่งความเป็นไปได้ใหม่สำหรับสถาปัตยกรรมไมโครฟรอนต์เอนด์:"}),"\n",(0,i.jsxs)(n.h3,{id:"ระบบโมดูลที่เป็นมาตรฐาน",children:["ระบบโมดูลที่เป็นมาตรฐาน",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ระบบโมดูลที่เป็นมาตรฐาน",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["ด้วยการสนับสนุน ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",target:"_blank",rel:"noopener noreferrer",children:"ES Modules"})," อย่างเต็มรูปแบบจากเบราว์เซอร์หลัก และความสมบูรณ์ของมาตรฐาน ",(0,i.jsx)(n.a,{href:"https://github.com/WICG/import-maps",target:"_blank",rel:"noopener noreferrer",children:"Import Maps"})," การพัฒนา frontend ได้เข้าสู่ยุคโมดูลาร์ที่แท้จริง ตามสถิติจาก ",(0,i.jsx)(n.a,{href:"https://caniuse.com/?search=importmap",target:"_blank",rel:"noopener noreferrer",children:"Can I Use"})," ปัจจุบันเบราว์เซอร์หลัก (Chrome >= 89, Edge >= 89, Firefox >= 108, Safari >= 16.4) มีอัตราการสนับสนุน ESM แบบเนทีฟถึง 93.5% ซึ่งให้ประโยชน์ดังต่อไปนี้:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"การจัดการ dependencies ที่เป็นมาตรฐาน"}),": Import Maps ให้ความสามารถในการ resolve dependencies ของโมดูลในระดับเบราว์เซอร์ โดยไม่ต้อง inject ที่ซับซ้อนใน runtime"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"การปรับปรุงประสิทธิภาพการโหลดทรัพยากร"}),": กลไกการแคชโมดูลแบบเนทีฟของเบราว์เซอร์ ช่วยปรับปรุงประสิทธิภาพการโหลดทรัพยากรอย่างมีนัยสำคัญ"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"การทำให้กระบวนการ build ง่ายขึ้น"}),": โหมดการพัฒนาที่ใช้ ESM ทำให้กระบวนการ build ของสภาพแวดล้อมการพัฒนาและสภาพแวดล้อมการผลิตมีความสอดคล้องกันมากขึ้น"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"นอกจากนี้ ผ่านการสนับสนุนโหมดความเข้ากันได้ (Chrome >= 87, Edge >= 88, Firefox >= 78, Safari >= 14) เราสามารถเพิ่มอัตราการครอบคลุมของเบราว์เซอร์ได้ถึง 96.81% ซึ่งทำให้เราสามารถรักษาประสิทธิภาพสูงได้โดยไม่เสียการสนับสนุนเบราว์เซอร์รุ่นเก่า"}),"\n",(0,i.jsxs)(n.h3,{id:"ความก้าวหน้าในด้านประสิทธิภาพและการแยกส่วน",children:["ความก้าวหน้าในด้านประสิทธิภาพและการแยกส่วน",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ความก้าวหน้าในด้านประสิทธิภาพและการแยกส่วน",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"ระบบโมดูลแบบเนทีฟไม่ได้นำมาซึ่งเพียงแค่มาตรฐานเท่านั้น แต่ยังรวมถึงการปรับปรุงประสิทธิภาพและการแยกส่วนที่สำคัญ:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ไม่มีค่าใช้จ่ายใน runtime"}),": ลาก่อน JavaScript sandbox proxy และการ inject ใน runtime ของโซลูชันไมโครฟรอนต์เอนด์แบบดั้งเดิม"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"กลไกการแยกส่วนที่เชื่อถือได้"}),": ขอบเขตโมดูลที่เข้มงวดของ ESM ให้ความสามารถในการแยกส่วนที่เชื่อถือได้มากที่สุด"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"การจัดการ dependencies ที่แม่นยำ"}),": การวิเคราะห์ static import ทำให้ความสัมพันธ์ของ dependencies ชัดเจนขึ้น และการควบคุมเวอร์ชันมีความแม่นยำมากขึ้น"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"การเลือกเครื่องมือ-build",children:["การเลือกเครื่องมือ build",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#การเลือกเครื่องมือ-build",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"ในการนำโซลูชันทางเทคนิคไปปฏิบัติ การเลือกเครื่องมือ build เป็นจุดตัดสินใจที่สำคัญ จากการวิจัยและปฏิบัติทางเทคนิคเกือบหนึ่งปี การเลือกของเราได้ผ่านการพัฒนาดังต่อไปนี้:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"การสำรวจ Vite"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ข้อดี: development server ที่ใช้ ESM ให้ประสบการณ์การพัฒนาที่ดีเยี่ยม"}),"\n",(0,i.jsx)(n.li,{children:"ความท้าทาย: ความแตกต่างระหว่างการ build ในสภาพแวดล้อมการพัฒนาและการผลิต ทำให้เกิดความไม่แน่นอนบางประการ"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["การเลือก ",(0,i.jsx)(n.a,{href:"https://www.rspack.dev/",target:"_blank",rel:"noopener noreferrer",children:"Rspack"})]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["ข้อได้เปรียบด้านประสิทธิภาพ: การคอมไพล์ประสิทธิภาพสูงที่ใช้ ",(0,i.jsx)(n.a,{href:"https://www.rust-lang.org/",target:"_blank",rel:"noopener noreferrer",children:"Rust"})," ช่วยปรับปรุงความเร็วในการ build อย่างมีนัยสำคัญ"]}),"\n",(0,i.jsx)(n.li,{children:"การสนับสนุน ecosystem: ความเข้ากันได้สูงกับ ecosystem ของ Webpack ช่วยลดต้นทุนการย้ายระบบ"}),"\n",(0,i.jsx)(n.li,{children:"การสนับสนุน ESM: ผ่านการปฏิบัติจริงของโครงการ Rslib ได้ยืนยันความน่าเชื่อถือในการ build ที่ใช้ ESM"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"การตัดสินใจนี้ทำให้เราสามารถรักษาประสบการณ์การพัฒนาได้ ในขณะที่ได้รับการสนับสนุนสภาพแวดล้อมการผลิตที่เสถียรมากขึ้น ด้วยการรวมกันของ ESM และ Rspack ในที่สุดเราก็ได้สร้างโซลูชันไมโครฟรอนต์เอนด์ที่มีประสิทธิภาพสูงและมีการรบกวนต่ำ"}),"\n",(0,i.jsxs)(n.h2,{id:"ทิศทางในอนาคต",children:["ทิศทางในอนาคต",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ทิศทางในอนาคต",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"ในแผนการพัฒนาของ Gez เฟรมเวิร์กจะมุ่งเน้นไปที่สามทิศทางหลักต่อไปนี้:"}),"\n",(0,i.jsxs)(n.h3,{id:"การปรับปรุง-import-maps-อย่างลึกซึ้ง",children:["การปรับปรุง Import Maps อย่างลึกซึ้ง",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#การปรับปรุง-import-maps-อย่างลึกซึ้ง",children:"#"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"การจัดการ dependencies แบบไดนามิก"}),": การจัดตารางเวอร์ชัน dependencies ใน runtime อย่างชาญฉลาด เพื่อแก้ปัญหาความขัดแย้งของ dependencies ระหว่างแอปพลิเคชันหลายตัว"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"กลยุทธ์การโหลดล่วงหน้า"}),": การโหลดล่วงหน้าที่ใช้การวิเคราะห์เส้นทาง เพื่อปรับปรุงประสิทธิภาพการโหลดทรัพยากร"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"การปรับปรุงการ build"}),": การสร้างการกำหนดค่า Import Maps ที่ดีที่สุดโดยอัตโนมัติ เพื่อลดต้นทุนการกำหนดค่าด้วยมือของนักพัฒนา"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"โซลูชัน-routing-ที่ไม่ขึ้นกับเฟรมเวิร์ก",children:["โซลูชัน routing ที่ไม่ขึ้นกับเฟรมเวิร์ก",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#โซลูชัน-routing-ที่ไม่ขึ้นกับเฟรมเวิร์ก",children:"#"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"การ abstraction routing ที่รวมเป็นหนึ่งเดียว"}),": การออกแบบอินเทอร์เฟซ routing ที่ไม่ขึ้นกับเฟรมเวิร์ก เพื่อสนับสนุนเฟรมเวิร์กหลักเช่น Vue, React"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"การ routing ของไมโครแอปพลิเคชัน"}),": การทำงานร่วมกันของ routing ระหว่างแอปพลิเคชัน เพื่อรักษาความสอดคล้องระหว่าง URL และสถานะของแอปพลิเคชัน"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"middleware routing"}),": การจัดเตรียมกลไก middleware ที่ขยายได้ เพื่อสนับสนุนการควบคุมสิทธิ์ การเปลี่ยนหน้า และฟังก์ชันอื่นๆ"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"แนวปฏิบัติที่ดีที่สุดในการสื่อสารข้ามเฟรมเวิร์ก",children:["แนวปฏิบัติที่ดีที่สุดในการสื่อสารข้ามเฟรมเวิร์ก",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#แนวปฏิบัติที่ดีที่สุดในการสื่อสารข้ามเฟรมเวิร์ก",children:"#"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"แอปพลิเคชันตัวอย่าง"}),": การจัดเตรียมตัวอย่างการสื่อสารข้ามเฟรมเวิร์กที่สมบูรณ์ ครอบคลุมเฟรมเวิร์กหลักเช่น Vue, React, Preact"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"การซิงโครไนซ์สถานะ"}),": โซลูชันการแชร์สถานะแบบเบาที่ใช้ ESM"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"event bus"}),": กลไกการสื่อสารเหตุการณ์ที่เป็นมาตรฐาน เพื่อสนับสนุนการสื่อสารที่แยกส่วนระหว่างแอปพลิเคชัน"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"ด้วยการปรับปรุงและขยายเหล่านี้ เราหวังว่า Gez จะกลายเป็นโซลูชันไมโครฟรอนต์เอนด์ที่สมบูรณ์และใช้งานง่ายมากขึ้น เพื่อมอบประสบการณ์การพัฒนาที่ดีขึ้นและประสิทธิภาพการพัฒนาที่สูงขึ้นให้กับนักพัฒนา"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}let h=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["th%2Fblog%2Fbirth-of-gez.md"]={toc:[{text:"ภูมิหลังของโครงการ",id:"ภูมิหลังของโครงการ",depth:2},{text:"ข้อจำกัดของโซลูชันแบบดั้งเดิม",id:"ข้อจำกัดของโซลูชันแบบดั้งเดิม",depth:3},{text:"การพัฒนาทางเทคนิค",id:"การพัฒนาทางเทคนิค",depth:2},{text:"v1.0: การสำรวจ Remote Component",id:"v10-การสำรวจ-remote-component",depth:3},{text:"v2.0: การทดลอง Module Federation",id:"v20-การทดลอง-module-federation",depth:3},{text:"การก้าวสู่ยุคใหม่ของ ESM",id:"การก้าวสู่ยุคใหม่ของ-esm",depth:2},{text:"ระบบโมดูลที่เป็นมาตรฐาน",id:"ระบบโมดูลที่เป็นมาตรฐาน",depth:3},{text:"ความก้าวหน้าในด้านประสิทธิภาพและการแยกส่วน",id:"ความก้าวหน้าในด้านประสิทธิภาพและการแยกส่วน",depth:3},{text:"การเลือกเครื่องมือ build",id:"การเลือกเครื่องมือ-build",depth:3},{text:"ทิศทางในอนาคต",id:"ทิศทางในอนาคต",depth:2},{text:"การปรับปรุง Import Maps อย่างลึกซึ้ง",id:"การปรับปรุง-import-maps-อย่างลึกซึ้ง",depth:3},{text:"โซลูชัน routing ที่ไม่ขึ้นกับเฟรมเวิร์ก",id:"โซลูชัน-routing-ที่ไม่ขึ้นกับเฟรมเวิร์ก",depth:3},{text:"แนวปฏิบัติที่ดีที่สุดในการสื่อสารข้ามเฟรมเวิร์ก",id:"แนวปฏิบัติที่ดีที่สุดในการสื่อสารข้ามเฟรมเวิร์ก",depth:3}],title:"จากส่วนประกอบที่ใช้ร่วมกันสู่โมดูลแบบเนทีฟ: เส้นทางวิวัฒนาการของเฟรมเวิร์กไมโครฟรอนต์เอนด์ Gez",headingTitle:"จากส่วนประกอบที่ใช้ร่วมกันสู่โมดูลแบบเนทีฟ: เส้นทางวิวัฒนาการของเฟรมเวิร์กไมโครฟรอนต์เอนด์ Gez",frontmatter:{titleSuffix:"จากปัญหาของไมโครฟรอนต์เอนด์สู่การสร้างสรรค์ด้วย ESM: เส้นทางวิวัฒนาการของเฟรมเวิร์ก Gez",description:"ศึกษาลึกถึงการพัฒนาของเฟรมเวิร์ก Gez จากปัญหาของสถาปัตยกรรมไมโครฟรอนต์เอนด์แบบดั้งเดิมสู่การสร้างสรรค์ด้วย ESM พร้อมแบ่งปันประสบการณ์ทางเทคนิคด้านการปรับปรุงประสิทธิภาพ การจัดการ dependencies และการเลือกเครื่องมือ build",head:[["meta",{property:"keywords",content:"Gez, ไมโครฟรอนต์เอนด์เฟรมเวิร์ก, ESM, Import Maps, Rspack, Module Federation, การจัดการ dependencies, การปรับปรุงประสิทธิภาพ, การพัฒนาทางเทคนิค, การเรนเดอร์ฝั่งเซิร์ฟเวอร์"}]],sidebar:!1}}}}]);