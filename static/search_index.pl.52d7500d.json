[{"id":225,"title":"@gez/rspack-vue","content":"#\n\nPakiet Rspack Vue dostarcza zestaw API do tworzenia i konfigurowania aplikacji\nRspack opartych na frameworku Vue, wspierając rozwój komponentów Vue, budowanie\noraz renderowanie po stronie serwera.\n\n\nInstalacja#\n\nZainstaluj @gez/rspack-vue jako zależność deweloperską za pomocą menedżera\npakietów:\n\n\nEksport typów#\n\n\nBuildTarget#\n\n\n\nTyp środowiska docelowego budowania, definiujący środowisko docelowe aplikacji,\nużywane do konfiguracji określonych optymalizacji i funkcji w procesie\nbudowania:\n\n * node: Budowanie kodu do uruchomienia w środowisku Node.js\n * client: Budowanie kodu do uruchomienia w środowisku przeglądarki\n * server: Budowanie kodu do uruchomienia w środowisku serwerowym\n\n\nRspackAppConfigContext#\n\n\n\nInterfejs kontekstu konfiguracji aplikacji Rspack, dostarczający informacji\nkontekstowych dostępnych w funkcjach hooków konfiguracyjnych:\n\n * gez: Instancja frameworku Gez\n * buildTarget: Aktualny cel budowania (client/server/node)\n * config: Obiekt konfiguracji Rspack\n * options: Opcje konfiguracji aplikacji\n\n\nRspackAppOptions#\n\n\n\nInterfejs opcji konfiguracji aplikacji Rspack:\n\n * css: Sposób wyjścia CSS, opcjonalnie 'css' (osobny plik) lub 'js' (wbudowany\n   w JS), domyślnie wybierany automatycznie w zależności od środowiska:\n   środowisko produkcyjne używa 'css' w celu optymalizacji pamięci podręcznej i\n   równoległego ładowania, środowisko deweloperskie używa 'js' w celu wsparcia\n   aktualizacji na gorąco (HMR)\n * loaders: Niestandardowa konfiguracja loaderów\n * styleLoader: Opcje konfiguracji style-loader\n * cssLoader: Opcje konfiguracji css-loader\n * target: Konfiguracja kompatybilności celu budowania\n * definePlugin: Definicje globalnych stałych\n * config: Funkcja hooka konfiguracyjnego\n\n\nRspackHtmlAppOptions#\n\nDziedziczy po RspackAppOptions, używane do konfiguracji specyficznych opcji\naplikacji HTML.\n\n\nEksport funkcji#\n\n\ncreateRspackApp#\n\n\n\nTworzy standardową instancję aplikacji Rspack.\n\nParametry:\n\n * gez: Instancja frameworku Gez\n * options: Opcje konfiguracji aplikacji Rspack\n\nWartość zwracana:\n\n * Zwraca Promise, który rozwiązuje się do utworzonej instancji aplikacji\n\n\ncreateRspackHtmlApp#\n\n\n\nTworzy instancję aplikacji Rspack typu HTML.\n\nParametry:\n\n * gez: Instancja frameworku Gez\n * options: Opcje konfiguracji aplikacji HTML\n\nWartość zwracana:\n\n * Zwraca Promise, który rozwiązuje się do utworzonej instancji aplikacji HTML\n\n\nEksport stałych#\n\n\nRSPACK_LOADER#\n\n\n\nObiekt mapowania identyfikatorów wbudowanych loaderów Rspack, dostarczający\nstałych nazw często używanych loaderów:\n\n * builtinSwcLoader: Wbudowany loader SWC w Rspack, używany do przetwarzania\n   plików TypeScript/JavaScript\n * lightningcssLoader: Wbudowany loader lightningcss w Rspack, używany do\n   przetwarzania plików CSS z wysoką wydajnością\n * styleLoader: Loader używany do wstrzykiwania CSS do DOM\n * cssLoader: Loader używany do parsowania plików CSS i obsługi modułów CSS\n * lessLoader: Loader używany do kompilacji plików Less do CSS\n * styleResourcesLoader: Loader używany do automatycznego importowania\n   globalnych zasobów stylów (np. zmiennych, mixins)\n * workerRspackLoader: Loader używany do przetwarzania plików Web Worker\n\nUżycie tych stałych pozwala na odwoływanie się do wbudowanych loaderów w\nkonfiguracji, unikając ręcznego wprowadzania ciągów znaków:\n\n\n\nUwagi:\n\n * Te loadery są już wbudowane w Rspack i nie wymagają dodatkowej instalacji\n * Podczas niestandardowej konfiguracji loaderów można użyć tych stałych do\n   zastąpienia domyślnych implementacji loaderów\n * Niektóre loadery (np. builtinSwcLoader) mają specyficzne opcje konfiguracji,\n   należy zapoznać się z odpowiednią dokumentacją konfiguracyjną\n\n\nEksport modułów#\n\n\nrspack#\n\nPonowny eksport całej zawartości pakietu @rspack/core, zapewniający pełną\nfunkcjonalność rdzenia Rspack.","routePath":"/pl/api/app/rspack-vue","lang":"pl","toc":[{"text":"Instalacja","id":"instalacja","depth":2,"charIndex":201},{"text":"Eksport typów","id":"eksport-typów","depth":2,"charIndex":301},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":318},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":694},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1034},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1732},{"text":"Eksport funkcji","id":"eksport-funkcji","depth":2,"charIndex":1849},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1868},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":2125},{"text":"Eksport stałych","id":"eksport-stałych","depth":2,"charIndex":2387},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2406},{"text":"Eksport modułów","id":"eksport-modułów","depth":2,"charIndex":3662},{"text":"rspack","id":"rspack","depth":3,"charIndex":3681}],"domain":"","frontmatter":{"titleSuffix":"Narzędzie do budowania Vue w ramach Gez","description":"Specjalistyczne narzędzie do budowania aplikacji Vue w ramach Gez, zapewniające pełne wsparcie dla aplikacji Vue 2/3, w tym rozwój komponentów, renderowanie SSR i optymalizację wydajności.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, narzędzie do budowania, rozwój komponentów, renderowanie po stronie serwera, optymalizacja wydajności"}]]},"version":""},{"id":226,"title":"@gez/rspack","content":"#\n\nPakiet Rspack dostarcza zestaw API do tworzenia i konfigurowania aplikacji\nRspack, wspierając budowanie i rozwój standardowych aplikacji oraz aplikacji\nHTML.\n\n\nInstalacja#\n\nZainstaluj zależność deweloperską @gez/rspack za pomocą menedżera pakietów:\n\n\nEksportowane Typy#\n\n\nBuildTarget#\n\n\n\nTyp środowiska docelowego budowania, definiujący środowisko docelowe aplikacji,\nużywane do konfigurowania określonych optymalizacji i funkcji w procesie\nbudowania:\n\n * node: Budowanie kodu do uruchomienia w środowisku Node.js\n * client: Budowanie kodu do uruchomienia w środowisku przeglądarki\n * server: Budowanie kodu do uruchomienia w środowisku serwerowym\n\n\nRspackAppConfigContext#\n\n\n\nInterfejs kontekstu konfiguracji aplikacji Rspack, dostarczający informacji\nkontekstowych dostępnych w funkcjach hooków konfiguracyjnych:\n\n * gez: Instancja frameworku Gez\n * buildTarget: Aktualny cel budowania (client/server/node)\n * config: Obiekt konfiguracji Rspack\n * options: Opcje konfiguracji aplikacji\n\n\nRspackAppOptions#\n\n\n\nInterfejs opcji konfiguracji aplikacji Rspack:\n\n * css: Sposób wyjścia CSS, opcjonalnie 'css' (osobny plik) lub 'js' (wbudowany\n   w JS), domyślnie wybierany automatycznie w zależności od środowiska:\n   środowisko produkcyjne używa 'css' w celu optymalizacji pamięci podręcznej i\n   równoległego ładowania, środowisko deweloperskie używa 'js' w celu wsparcia\n   Hot Module Replacement (HMR)\n * loaders: Niestandardowa konfiguracja loaderów\n * styleLoader: Opcje konfiguracji style-loader\n * cssLoader: Opcje konfiguracji css-loader\n * target: Konfiguracja kompatybilności celu budowania\n * definePlugin: Definicje globalnych stałych\n * config: Funkcja hooka konfiguracyjnego\n\n\nRspackHtmlAppOptions#\n\nDziedziczy po RspackAppOptions, używane do konfigurowania specyficznych opcji\naplikacji HTML.\n\n\nEksportowane Funkcje#\n\n\ncreateRspackApp#\n\n\n\nTworzy standardową instancję aplikacji Rspack.\n\nParametry:\n\n * gez: Instancja frameworku Gez\n * options: Opcje konfiguracji aplikacji Rspack\n\nWartość zwracana:\n\n * Zwraca Promise, który rozwiązuje się do utworzonej instancji aplikacji\n\n\ncreateRspackHtmlApp#\n\n\n\nTworzy instancję aplikacji Rspack typu HTML.\n\nParametry:\n\n * gez: Instancja frameworku Gez\n * options: Opcje konfiguracji aplikacji HTML\n\nWartość zwracana:\n\n * Zwraca Promise, który rozwiązuje się do utworzonej instancji aplikacji HTML\n\n\nEksportowane Stałe#\n\n\nRSPACK_LOADER#\n\n\n\nObiekt mapujący wbudowane identyfikatory loaderów Rspack, dostarczający stałe\nnazwy często używanych loaderów:\n\n * builtinSwcLoader: Wbudowany loader SWC w Rspack, używany do przetwarzania\n   plików TypeScript/JavaScript\n * lightningcssLoader: Wbudowany loader lightningcss w Rspack, używany do\n   przetwarzania plików CSS z wysoką wydajnością\n * styleLoader: Loader używany do wstrzykiwania CSS do DOM\n * cssLoader: Loader używany do parsowania plików CSS i obsługi modułów CSS\n * lessLoader: Loader używany do kompilacji plików Less do CSS\n * styleResourcesLoader: Loader używany do automatycznego importowania\n   globalnych zasobów stylów (np. zmiennych, mixins)\n * workerRspackLoader: Loader używany do przetwarzania plików Web Worker\n\nUżywanie tych stałych pozwala na odwoływanie się do wbudowanych loaderów w\nkonfiguracji, unikając ręcznego wpisywania ciągów znaków:\n\n\n\nUwagi:\n\n * Te loadery są już wbudowane w Rspack, nie wymagają dodatkowej instalacji\n * Podczas niestandardowej konfiguracji loaderów można użyć tych stałych do\n   zastąpienia domyślnych implementacji loaderów\n * Niektóre loadery (np. builtinSwcLoader) mają specyficzne opcje konfiguracji,\n   proszę zapoznać się z odpowiednią dokumentacją konfiguracyjną\n\n\nEksportowane Moduły#\n\n\nrspack#\n\nPonownie eksportuje całą zawartość pakietu @rspack/core, dostarczając pełną\nfunkcjonalność rdzenia Rspack.","routePath":"/pl/api/app/rspack","lang":"pl","toc":[{"text":"Instalacja","id":"instalacja","depth":2,"charIndex":162},{"text":"Eksportowane Typy","id":"eksportowane-typy","depth":2,"charIndex":253},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":274},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":652},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":992},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1690},{"text":"Eksportowane Funkcje","id":"eksportowane-funkcje","depth":2,"charIndex":1809},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1833},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":2090},{"text":"Eksportowane Stałe","id":"eksportowane-stałe","depth":2,"charIndex":2352},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2374},{"text":"Eksportowane Moduły","id":"eksportowane-moduły","depth":2,"charIndex":3624},{"text":"rspack","id":"rspack","depth":3,"charIndex":3647}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Rspack Narzędzie Budowania","description":"Narzędzie budowania Rspack dla frameworku Gez, zapewniające wysoką wydajność w budowaniu aplikacji, wspierające rozwój i budowanie standardowych aplikacji oraz aplikacji HTML, z wbudowanymi różnymi procesorami zasobów i zoptymalizowanymi konfiguracjami.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, narzędzie budowania, budowanie aplikacji, aplikacja HTML, TypeScript, CSS, przetwarzanie zasobów, optymalizacja wydajności"}]]},"version":""},{"id":227,"title":"App","content":"#\n\nApp to abstrakcja aplikacji w frameworku Gez, która zapewnia ujednolicony\ninterfejs do zarządzania cyklem życia aplikacji, zasobami statycznymi oraz\nrenderowaniem po stronie serwera.\n\n\n\n\nDefinicje typów#\n\n\nApp#\n\n\n\nmiddleware#\n\n * Typ: Middleware\n\nMiddleware do obsługi zasobów statycznych.\n\nŚrodowisko deweloperskie:\n\n * Obsługuje żądania zasobów statycznych z kodu źródłowego\n * Obsługuje kompilację w czasie rzeczywistym i gorącą aktualizację\n * Używa strategii cache bez buforowania (no-cache)\n\nŚrodowisko produkcyjne:\n\n * Obsługuje zasoby statyczne po zbudowaniu\n * Obsługuje długotrwałe buforowanie niezmiennych plików (.final.xxx)\n * Zoptymalizowana strategia ładowania zasobów\n\n\n\nrender#\n\n * Typ: (options?: RenderContextOptions) => Promise\n\nFunkcja renderowania po stronie serwera. Zapewnia różne implementacje w\nzależności od środowiska:\n\n * Środowisko produkcyjne (start): Ładuje zbudowany plik wejściowy serwera\n   (entry.server) i wykonuje renderowanie\n * Środowisko deweloperskie (dev): Ładuje plik wejściowy serwera z kodu\n   źródłowego i wykonuje renderowanie\n\n\n\nbuild#\n\n * Typ: () => Promise\n\nFunkcja budowania dla środowiska produkcyjnego. Służy do pakowania i\noptymalizacji zasobów. Zwraca true w przypadku powodzenia budowania, false w\nprzypadku niepowodzenia.\n\ndestroy#\n\n * Typ: () => Promise\n\nFunkcja czyszczenia zasobów. Służy do zamykania serwera, rozłączania połączeń\nitp. Zwraca true w przypadku powodzenia czyszczenia, false w przypadku\nniepowodzenia.","routePath":"/pl/api/core/app","lang":"pl","toc":[{"text":"Definicje typów","id":"definicje-typów","depth":2,"charIndex":189},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":216},{"text":"render","id":"render","depth":4,"charIndex":689},{"text":"build","id":"build","depth":4,"charIndex":1080},{"text":"destroy","id":"destroy","depth":4,"charIndex":1283}],"domain":"","frontmatter":{"titleSuffix":"Abstrakcyjny interfejs aplikacji frameworku Gez","description":"Szczegółowy opis interfejsu App frameworku Gez, obejmujący zarządzanie cyklem życia aplikacji, obsługę zasobów statycznych oraz renderowanie po stronie serwera, pomagający programistom zrozumieć i wykorzystać kluczowe funkcje aplikacji.","head":[["meta",{"property":"keywords","content":"Gez, App, abstrakcja aplikacji, cykl życia, zasoby statyczne, renderowanie po stronie serwera, API"}]]},"version":""},{"id":228,"title":"Gez","content":"#\n\n\nWprowadzenie#\n\nGez to wysokowydajny framework aplikacji webowych oparty na Rspack, zapewniający\nkompleksowe zarządzanie cyklem życia aplikacji, obsługę zasobów statycznych oraz\nmożliwości renderowania po stronie serwera.\n\n\nDefinicje typów#\n\n\nRuntimeTarget#\n\n * Definicja typu:\n\n\n\nTyp środowiska uruchomieniowego aplikacji:\n\n * client: Działa w środowisku przeglądarki, obsługuje operacje na DOM i API\n   przeglądarki\n * server: Działa w środowisku Node.js, obsługuje system plików i funkcje\n   serwerowe\n\n\nImportMap#\n\n * Definicja typu:\n\n\n\nTyp mapowania importów modułów ES.\n\nSpecifierMap#\n\n * Definicja typu:\n\n\n\nTyp mapowania identyfikatorów modułów, używany do definiowania mapowania ścieżek\nimportu modułów.\n\nScopesMap#\n\n * Definicja typu:\n\n\n\nTyp mapowania zakresów, używany do definiowania mapowania importu modułów w\nokreślonych zakresach.\n\n\nCOMMAND#\n\n * Definicja typu:\n\n\n\nTyp wyliczeniowy poleceń:\n\n * dev: Polecenie środowiska deweloperskiego, uruchamia serwer deweloperski z\n   obsługą hot-reload\n * build: Polecenie budowania, generuje artefakty produkcyjne\n * preview: Polecenie podglądu, uruchamia lokalny serwer podglądu\n * start: Polecenie uruchomienia, uruchamia serwer produkcyjny\n\n\nOpcje instancji#\n\nDefiniuje kluczowe opcje konfiguracyjne frameworka Gez.\n\n\n\nroot#\n\n * Typ: string\n * Domyślna wartość: process.cwd()\n\nŚcieżka do katalogu głównego projektu. Może być ścieżką bezwzględną lub\nwzględną, względna ścieżka jest rozwiązywana względem bieżącego katalogu\nroboczego.\n\nisProd#\n\n * Typ: boolean\n * Domyślna wartość: process.env.NODE_ENV === 'production'\n\nIdentyfikator środowiska.\n\n * true: Środowisko produkcyjne\n * false: Środowisko deweloperskie\n\nbasePathPlaceholder#\n\n * Typ: string | false\n * Domyślna wartość: '[[[___GEZ_DYNAMIC_BASE___]]]'\n\nKonfiguracja symbolu zastępczego ścieżki bazowej. Używany do dynamicznego\nzastępowania ścieżki bazowej zasobów w czasie wykonywania. Ustawienie na false\nwyłącza tę funkcję.\n\nmodules#\n\n * Typ: ModuleConfig\n\nOpcje konfiguracyjne modułów. Używane do konfiguracji reguł rozwiązywania\nmodułów w projekcie, w tym aliasów modułów, zależności zewnętrznych itp.\n\npacks#\n\n * Typ: PackConfig\n\nOpcje konfiguracyjne pakowania. Używane do pakowania artefaktów budowania w\nstandardowe pakiety npm w formacie .tgz.\n\ndevApp#\n\n * Typ: (gez: Gez) => Promise\n\nFunkcja tworzenia aplikacji dla środowiska deweloperskiego. Używana tylko w\nśrodowisku deweloperskim do tworzenia instancji aplikacji serwera\ndeweloperskiego.\n\n\n\nserver#\n\n * Typ: (gez: Gez) => Promise\n\nFunkcja konfiguracji i uruchamiania serwera HTTP. Używana do konfiguracji i\nuruchamiania serwera HTTP, dostępna zarówno w środowisku deweloperskim, jak i\nprodukcyjnym.\n\n\n\npostBuild#\n\n * Typ: (gez: Gez) => Promise\n\nFunkcja przetwarzania po budowaniu. Wykonywana po zakończeniu budowania\nprojektu, może być używana do:\n\n * Wykonywania dodatkowego przetwarzania zasobów\n * Operacji wdrażania\n * Generowania plików statycznych\n * Wysyłania powiadomień o budowaniu\n\n\nWłaściwości instancji#\n\n\nname#\n\n * Typ: string\n * Tylko do odczytu: true\n\nNazwa bieżącego modułu, pochodząca z konfiguracji modułu.\n\n\nvarName#\n\n * Typ: string\n * Tylko do odczytu: true\n\nPrawidłowa nazwa zmiennej JavaScript wygenerowana na podstawie nazwy modułu.\n\n\nroot#\n\n * Typ: string\n * Tylko do odczytu: true\n\nBezwzględna ścieżka do katalogu głównego projektu. Jeśli skonfigurowany root\njest ścieżką względną, jest rozwiązywany względem bieżącego katalogu roboczego.\n\n\nisProd#\n\n * Typ: boolean\n * Tylko do odczytu: true\n\nOkreśla, czy bieżące środowisko jest produkcyjne. Priorytetowo używana jest\nopcja isProd z konfiguracji, jeśli nie jest skonfigurowana, jest określane na\npodstawie process.env.NODE_ENV.\n\n\nbasePath#\n\n * Typ: string\n * Tylko do odczytu: true\n * Rzuca: NotReadyError - gdy framework nie jest zainicjalizowany\n\nPobiera ścieżkę bazową modułu rozpoczynającą się i kończącą się ukośnikiem.\nZwraca format /${name}/, gdzie name pochodzi z konfiguracji modułu.\n\n\nbasePathPlaceholder#\n\n * Typ: string\n * Tylko do odczytu: true\n\nPobiera symbol zastępczy ścieżki bazowej używany do dynamicznego zastępowania w\nczasie wykonywania. Może być wyłączony przez konfigurację.\n\n\nmiddleware#\n\n * Typ: Middleware\n * Tylko do odczytu: true\n\nPobiera middleware do obsługi zasobów statycznych. Dostarcza różne implementacje\nw zależności od środowiska:\n\n * Środowisko deweloperskie: Obsługa kompilacji w locie i hot-reload\n * Środowisko produkcyjne: Obsługa długotrwałego buforowania zasobów statycznych\n\n\n\n\nrender#\n\n * Typ: (options?: RenderContextOptions) => Promise\n * Tylko do odczytu: true\n\nPobiera funkcję renderowania po stronie serwera. Dostarcza różne implementacje w\nzależności od środowiska:\n\n * Środowisko deweloperskie: Obsługa hot-reload i podglądu w locie\n * Środowisko produkcyjne: Zapewnia zoptymalizowaną wydajność renderowania\n\n\n\n\nCOMMAND#\n\n * Typ: typeof COMMAND\n * Tylko do odczytu: true\n\nPobiera definicję typu wyliczeniowego poleceń.\n\n\nmoduleConfig#\n\n * Typ: ParsedModuleConfig\n * Tylko do odczytu: true\n * Rzuca: NotReadyError - gdy framework nie jest zainicjalizowany\n\nPobiera pełną konfigurację bieżącego modułu, w tym reguły rozwiązywania modułów,\nkonfigurację aliasów itp.\n\n\npackConfig#\n\n * Typ: ParsedPackConfig\n * Tylko do odczytu: true\n * Rzuca: NotReadyError - gdy framework nie jest zainicjalizowany\n\nPobiera konfigurację związaną z pakowaniem bieżącego modułu, w tym ścieżkę\nwyjściową, przetwarzanie package.json itp.\n\n\nMetody instancji#\n\n\nconstructor()#\n\n * Parametry:\n   * options?: GezOptions - Opcje konfiguracyjne frameworka\n * Zwraca: Gez\n\nTworzy instancję frameworka Gez.\n\n\n\n\ninit()#\n\n * Parametry: command: COMMAND\n * Zwraca: Promise\n * Rzuca:\n   * Error: Przy ponownej inicjalizacji\n   * NotReadyError: Przy dostępie do nieinicjalizowanej instancji\n\nInicjalizuje instancję frameworka Gez. Wykonuje następujące kluczowe kroki\ninicjalizacji:\n\n 1. Parsuje konfigurację projektu (package.json, konfiguracja modułów,\n    konfiguracja pakowania itp.)\n 2. Tworzy instancję aplikacji (środowisko deweloperskie lub produkcyjne)\n 3. Wykonuje odpowiednie metody cyklu życia w zależności od polecenia\n\nUwaga\n * Ponowna inicjalizacja rzuca błąd\n * Dostęp do nieinicjalizowanej instancji rzuca NotReadyError\n\n\n\n\ndestroy()#\n\n * Zwraca: Promise\n\nNiszczy instancję frameworka Gez, wykonując czyszczenie zasobów i zamykanie\npołączeń. Głównie używane do:\n\n * Zamykania serwera deweloperskiego\n * Czyszczenia plików tymczasowych i pamięci podręcznej\n * Zwolnienia zasobów systemowych\n\n\n\n\nbuild()#\n\n * Zwraca: Promise\n\nWykonuje proces budowania aplikacji, w tym:\n\n * Kompilację kodu źródłowego\n * Generowanie artefaktów produkcyjnych\n * Optymalizację i kompresję kodu\n * Generowanie manifestu zasobów\n\nUwaga\n\nWywołanie przed inicjalizacją instancji frameworka rzuca NotReadyError\n\n\n\n\nserver()#\n\n * Zwraca: Promise\n * Rzuca: NotReadyError - gdy framework nie jest zainicjalizowany\n\nUruchamia serwer HTTP i konfiguruje instancję serwera. Wywoływane w\nnastępujących cyklach życia:\n\n * Środowisko deweloperskie (dev): Uruchamia serwer deweloperski z obsługą\n   hot-reload\n * Środowisko produkcyjne (start): Uruchamia serwer produkcyjny z wydajnością\n   produkcyjną\n\n\n\n\npostBuild()#\n\n * Zwraca: Promise\n\nWykonuje logikę przetwarzania po budowaniu, używana do:\n\n * Generowania statycznych plików HTML\n * Przetwarzania artefaktów budowania\n * Wykonywania zadań wdrażania\n * Wysyłania powiadomień o budowaniu\n\n\n\n\nresolvePath#\n\nRozwiązuje ścieżkę projektu, konwertując ścieżkę względną na bezwzględną.\n\n * Parametry:\n   \n   * projectPath: ProjectPath - Typ ścieżki projektu\n   * ...args: string[] - Fragmenty ścieżki\n\n * Zwraca: string - Rozwiązana ścieżka bezwzględna\n\n * Przykład:\n\n\n\n\nwriteSync()#\n\nSynchroniczne zapisywanie zawartości do pliku.\n\n * Parametry:\n   \n   * filepath: string - Bezwzględna ścieżka do pliku\n   * data: any - Dane do zapisania, mogą być ciągiem znaków, Bufferem lub\n     obiektem\n\n * Zwraca: boolean - Czy zapis się powiódł\n\n * Przykład:\n\n\n\n\nreadJsonSync()#\n\nSynchroniczne odczytywanie i parsowanie pliku JSON.\n\n * Parametry:\n   \n   * filename: string - Bezwzględna ścieżka do pliku JSON\n\n * Zwraca: any - Sparsowany obiekt JSON\n\n * Wyjątki: Rzuca wyjątek, gdy plik nie istnieje lub format JSON jest\n   nieprawidłowy\n\n * Przykład:\n\n\n\n\nreadJson()#\n\nAsynchroniczne odczytywanie i parsowanie pliku JSON.\n\n * **Param","routePath":"/pl/api/core/gez","lang":"pl","toc":[{"text":"Wprowadzenie","id":"wprowadzenie","depth":2,"charIndex":3},{"text":"Definicje typów","id":"definicje-typów","depth":2,"charIndex":226},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":245},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":509},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":579},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":715},{"text":"COMMAND","id":"command","depth":3,"charIndex":850},{"text":"Opcje instancji","id":"opcje-instancji","depth":2,"charIndex":1202},{"text":"root","id":"root","depth":4,"charIndex":1279},{"text":"isProd","id":"isprod","depth":4,"charIndex":1494},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":1674},{"text":"modules","id":"modules","depth":4,"charIndex":1946},{"text":"packs","id":"packs","depth":4,"charIndex":2126},{"text":"devApp","id":"devapp","depth":4,"charIndex":2272},{"text":"server","id":"server","depth":4,"charIndex":2474},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":2685},{"text":"Właściwości instancji","id":"właściwości-instancji","depth":2,"charIndex":2976},{"text":"name","id":"name","depth":3,"charIndex":3001},{"text":"varName","id":"varname","depth":3,"charIndex":3110},{"text":"root","id":"root-1","depth":3,"charIndex":3241},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":3449},{"text":"basePath","id":"basepath","depth":3,"charIndex":3689},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":3954},{"text":"middleware","id":"middleware","depth":3,"charIndex":4159},{"text":"render","id":"render","depth":3,"charIndex":4482},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":4824},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":4933},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":5177},{"text":"Metody instancji","id":"metody-instancji","depth":2,"charIndex":5428},{"text":"constructor()","id":"constructor","depth":3,"charIndex":5448},{"text":"init()","id":"init","depth":3,"charIndex":5591},{"text":"destroy()","id":"destroy","depth":3,"charIndex":6215},{"text":"build()","id":"build","depth":3,"charIndex":6485},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":7401},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":7674},{"text":"readJsonSync()","id":"readjsonsync","depth":3,"charIndex":7957},{"text":"readJson()","id":"readjson","depth":3,"charIndex":8250}],"domain":"","frontmatter":{"titleSuffix":"Dokumentacja API klas rdzeniowych frameworka","description":"Szczegółowy opis API klas rdzeniowych frameworka Gez, obejmujący zarządzanie cyklem życia aplikacji, obsługę zasobów statycznych oraz możliwości renderowania po stronie serwera, pomagający programistom dogłębnie zrozumieć kluczowe funkcje frameworka.","head":[["meta",{"property":"keywords","content":"Gez, API, zarządzanie cyklem życia, zasoby statyczne, renderowanie po stronie serwera, Rspack, framework aplikacji webowych"}]]},"version":""},{"id":229,"title":"ManifestJson","content":"#\n\nmanifest.json to plik manifestu generowany przez framework Gez podczas procesu\nbudowania, służący do rejestrowania informacji o artefaktach budowania usługi.\nDostarcza ujednoliconego interfejsu do zarządzania artefaktami budowania,\nplikami eksportowymi oraz statystykami rozmiaru zasobów.\n\n\n\n\nDefinicje typów#\n\n\nManifestJson#\n\n\n\nname#\n\n * Typ: string\n\nNazwa usługi, pochodząca z konfiguracji GezOptions.name.\n\nexports#\n\n * Typ: Record\n\nMapowanie plików eksportowych, gdzie klucz to ścieżka do pliku źródłowego, a\nwartość to ścieżka do pliku po budowaniu.\n\nbuildFiles#\n\n * Typ: string[]\n\nPełna lista plików artefaktów budowania, zawierająca wszystkie wygenerowane\nścieżki plików.\n\nchunks#\n\n * Typ: Record\n\nOdpowiedniość między plikami źródłowymi a skompilowanymi artefaktami, gdzie\nklucz to ścieżka do pliku źródłowego, a wartość to informacje o kompilacji.\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * Typ: string\n\nŚcieżka do pliku JS skompilowanego z bieżącego pliku źródłowego.\n\ncss#\n\n * Typ: string[]\n\nLista ścieżek do plików CSS powiązanych z bieżącym plikiem źródłowym.\n\nresources#\n\n * Typ: string[]\n\nLista ścieżek do innych plików zasobów powiązanych z bieżącym plikiem źródłowym.\n\nsizes#\n\n * Typ: ManifestJsonChunkSizes\n\nStatystyki rozmiaru artefaktów budowania.\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * Typ: number\n\nRozmiar pliku JS (w bajtach).\n\ncss#\n\n * Typ: number\n\nRozmiar pliku CSS (w bajtach).\n\nresource#\n\n * Typ: number\n\nRozmiar pliku zasobu (w bajtach).","routePath":"/pl/api/core/manifest-json","lang":"pl","toc":[{"text":"Definicje typów","id":"definicje-typów","depth":2,"charIndex":295},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":331},{"text":"exports","id":"exports","depth":4,"charIndex":412},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":558},{"text":"chunks","id":"chunks","depth":4,"charIndex":682},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":861},{"text":"js","id":"js","depth":4,"charIndex":884},{"text":"css","id":"css","depth":4,"charIndex":971},{"text":"resources","id":"resources","depth":4,"charIndex":1066},{"text":"sizes","id":"sizes","depth":4,"charIndex":1178},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":1262},{"text":"js","id":"js-1","depth":4,"charIndex":1289},{"text":"css","id":"css-1","depth":4,"charIndex":1341},{"text":"resource","id":"resource","depth":4,"charIndex":1395}],"domain":"","frontmatter":{"titleSuffix":"Dokumentacja pliku manifestu frameworku Gez","description":"Szczegółowy opis struktury pliku manifestu (manifest.json) frameworku Gez, obejmujący zarządzanie artefaktami budowania, mapowanie plików eksportowych oraz statystyki zasobów, aby pomóc programistom w zrozumieniu i wykorzystaniu systemu budowania.","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, manifest budowania, zarządzanie zasobami, artefakty budowania, mapowanie plików, API"}]]},"version":""},{"id":230,"title":"ModuleConfig","content":"#\n\nModuleConfig zapewnia funkcjonalność konfiguracji modułów w frameworku Gez,\nsłużącą do definiowania reguł importu i eksportu modułów, konfiguracji aliasów\noraz zależności zewnętrznych.\n\n\nDefinicje typów#\n\n\nPathType#\n\n * Definicja typu:\n\n\n\nEnum typów ścieżek modułów:\n\n * npm: oznacza zależność z node_modules\n * root: oznacza plik w katalogu głównym projektu\n\n\nModuleConfig#\n\n * Definicja typu:\n\n\n\nInterfejs konfiguracji modułów, służący do definiowania eksportu, importu i\nkonfiguracji zależności zewnętrznych usług.\n\nexports#\n\nLista konfiguracji eksportu, która udostępnia określone jednostki kodu (np.\nkomponenty, funkcje narzędziowe) w formacie ESM.\n\nObsługiwane są dwa typy:\n\n * root:*: eksport plików źródłowych, np.: 'root:src/components/button.vue'\n * npm:*: eksport zależności zewnętrznych, np.: 'npm:vue'\n\nimports#\n\nMapa konfiguracji importu, konfigurująca zdalne moduły do zaimportowania i ich\nlokalne ścieżki.\n\nKonfiguracja zależy od sposobu instalacji:\n\n * Instalacja ze źródeł (Workspace, Git): wymaga wskazania katalogu dist\n * Instalacja pakietów (Link, serwer statyczny, prywatne repozytorium, File):\n   bezpośrednio wskazuje katalog pakietu\n\nexternals#\n\nMapa zależności zewnętrznych, konfigurująca zależności zewnętrzne do użycia,\nzazwyczaj pochodzące ze zdalnych modułów.\n\nPrzykład:\n\n\n\n\nParsedModuleConfig#\n\n * Definicja typu:\n\n\n\nSparsowana konfiguracja modułów, przekształcająca oryginalną konfigurację\nmodułów w znormalizowany format wewnętrzny:\n\nname#\n\nNazwa bieżącej usługi\n\n * Służy do identyfikacji modułu i generowania ścieżek importu\n\nroot#\n\nŚcieżka katalogu głównego bieżącej usługi\n\n * Służy do rozwiązywania ścieżek względnych i przechowywania artefaktów budowy\n\nexports#\n\nLista konfiguracji eksportu\n\n * name: oryginalna ścieżka eksportu, np.: 'npm:vue' lub 'root:src/components'\n * type: typ ścieżki (npm lub root)\n * importName: nazwa importu, format: '${serviceName}/${type}/${path}'\n * exportName: ścieżka eksportu, względem katalogu głównego usługi\n * exportPath: rzeczywista ścieżka pliku\n * externalName: nazwa zależności zewnętrznej, służąca do identyfikacji tego\n   modułu podczas importu przez inne usługi\n\nimports#\n\nLista konfiguracji importu\n\n * name: nazwa zewnętrznej usługi\n * localPath: lokalna ścieżka przechowywania, służąca do przechowywania\n   artefaktów budowy zewnętrznych modułów\n\nexternals#\n\nMapa zależności zewnętrznych\n\n * Mapuje ścieżki importu modułów na rzeczywiste lokalizacje modułów\n * match: wyrażenie regularne do dopasowania instrukcji importu\n * import: rzeczywista ścieżka modułu","routePath":"/pl/api/core/module-config","lang":"pl","toc":[{"text":"Definicje typów","id":"definicje-typów","depth":2,"charIndex":189},{"text":"PathType","id":"pathtype","depth":3,"charIndex":208},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":521},{"text":"imports","id":"imports","depth":4,"charIndex":818},{"text":"externals","id":"externals","depth":4,"charIndex":1162},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":1308},{"text":"name","id":"name","depth":4,"charIndex":1470},{"text":"root","id":"root","depth":4,"charIndex":1564},{"text":"exports","id":"exports-1","depth":4,"charIndex":1695},{"text":"imports","id":"imports-1","depth":4,"charIndex":2150},{"text":"externals","id":"externals-1","depth":4,"charIndex":2337}],"domain":"","frontmatter":{"titleSuffix":"Dokumentacja API konfiguracji modułów frameworka Gez","description":"Szczegółowy opis interfejsu konfiguracji ModuleConfig frameworka Gez, obejmujący reguły importu i eksportu modułów, konfigurację aliasów oraz zarządzanie zależnościami zewnętrznymi, pomagający programistom dogłębnie zrozumieć system modułowy frameworka.","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, konfiguracja modułów, import i eksport modułów, zależności zewnętrzne, konfiguracja aliasów, zarządzanie zależnościami, framework aplikacji webowych"}]]},"version":""},{"id":231,"title":"PackConfig","content":"#\n\nPackConfig to interfejs konfiguracji pakowania pakietów, służący do pakowania\nwyników budowania usługi w standardowy format pakietu npm .tgz.\n\n * Standaryzacja: Używa standardowego formatu pakowania npm .tgz\n * Kompletność: Zawiera wszystkie niezbędne pliki, takie jak kod źródłowy\n   modułu, deklaracje typów i pliki konfiguracyjne\n * Kompatybilność: W pełni kompatybilny z ekosystemem npm, wspiera standardowe\n   przepływy pracy zarządzania pakietami\n\n\nDefinicja typów#\n\n\n\n\nPackConfig#\n\nenable#\n\nOkreśla, czy funkcja pakowania jest włączona. Po włączeniu wyniki budowania\nzostaną spakowane w standardowy format pakietu npm .tgz.\n\n * Typ: boolean\n * Wartość domyślna: false\n\noutputs#\n\nOkreśla ścieżkę wyjściową pliku pakietu. Obsługiwane są następujące sposoby\nkonfiguracji:\n\n * string: Pojedyncza ścieżka wyjściowa, np. 'dist/versions/my-app.tgz'\n * string[]: Wiele ścieżek wyjściowych, służących do jednoczesnego generowania\n   wielu wersji\n * boolean: true - używa domyślnej ścieżki 'dist/client/versions/latest.tgz'\n\npackageJson#\n\nFunkcja zwrotna do dostosowywania zawartości pliku package.json. Wywoływana\nprzed pakowaniem, służy do dostosowywania zawartości pliku package.json.\n\n * Parametry:\n   * gez: Gez - Instancja Gez\n   * pkg: any - Oryginalna zawartość pliku package.json\n * Wartość zwracana: Promise - Zmodyfikowana zawartość pliku package.json\n\nTypowe zastosowania:\n\n * Modyfikacja nazwy pakietu i numeru wersji\n * Dodawanie lub aktualizacja zależności\n * Dodawanie niestandardowych pól\n * Konfiguracja informacji związanych z publikacją\n\nPrzykład:\n\n\n\nonBefore#\n\nFunkcja zwrotna do przygotowań przed pakowaniem.\n\n * Parametry:\n   * gez: Gez - Instancja Gez\n   * pkg: Record - Zawartość pliku package.json\n * Wartość zwracana: Promise\n\nTypowe zastosowania:\n\n * Dodawanie dodatkowych plików (README, LICENSE itp.)\n * Wykonywanie testów lub weryfikacji budowania\n * Generowanie dokumentacji lub metadanych\n * Czyszczenie plików tymczasowych\n\nPrzykład:\n\n\n\nonAfter#\n\nFunkcja zwrotna do przetwarzania po zakończeniu pakowania. Wywoływana po\nwygenerowaniu pliku .tgz, służy do przetwarzania wyników pakowania.\n\n * Parametry:\n   * gez: Gez - Instancja Gez\n   * pkg: Record - Zawartość pliku package.json\n   * file: Buffer - Zawartość spakowanego pliku\n * Wartość zwracana: Promise\n\nTypowe zastosowania:\n\n * Publikacja do repozytorium npm (publicznego lub prywatnego)\n * Przesyłanie do serwera zasobów statycznych\n * Zarządzanie wersjami\n * Wyzwalanie procesów CI/CD\n\nPrzykład:\n\n\n\n\nPrzykład użycia#\n\n","routePath":"/pl/api/core/pack-config","lang":"pl","toc":[{"text":"Definicja typów","id":"definicja-typów","depth":2,"charIndex":457},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":491},{"text":"outputs","id":"outputs","depth":4,"charIndex":678},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":1024},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":1570},{"text":"onAfter","id":"onafter","depth":4,"charIndex":1970},{"text":"Przykład użycia","id":"przykład-użycia","depth":2,"charIndex":2491}],"domain":"","frontmatter":{"titleSuffix":"Dokumentacja API konfiguracji pakowania frameworku Gez","description":"Szczegółowy opis interfejsu konfiguracyjnego PackConfig frameworku Gez, obejmujący reguły pakowania pakietów, konfigurację wyjściową i hooki cyklu życia, pomagający programistom w implementacji standardowych procesów budowania.","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, pakowanie pakietów, konfiguracja budowania, hooki cyklu życia, konfiguracja pakowania, framework aplikacji webowych"}]]},"version":""},{"id":232,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/pl/api/core/render-context","lang":"pl","toc":[{"text":"Definicje typów","id":"definicje-typów","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"Opcje instancji","id":"opcje-instancji","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"Właściwości instancji","id":"właściwości-instancji","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"Metody instancji","id":"metody-instancji","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1},{"text":"commit()","id":"commit","depth":3,"charIndex":-1},{"text":"preload()","id":"preload","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Dokumentacja API kontekstu renderowania frameworka Gez","description":"Szczegółowy opis klasy RenderContext, rdzenia frameworka Gez, obejmujący kontrolę renderowania, zarządzanie zasobami, synchronizację stanu i kontrolę routingu, pomagający programistom w efektywnym renderowaniu po stronie serwera.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, renderowanie po stronie serwera, kontekst renderowania, synchronizacja stanu, zarządzanie zasobami, framework aplikacji webowych"}]]},"version":""},{"id":233,"title":"Od współdzielenia komponentów do natywnej modularności: Droga ewolucji frameworka mikrofrontendów Gez","content":"Od współdzielenia komponentów do natywnej modularności: Droga ewolucji\nframeworka mikrofrontendów Gez#\n\n\nTło projektu#\n\nW ciągu ostatnich kilku lat architektura mikrofrontendów szukała właściwej\ndrogi. Jednak obserwowaliśmy różne skomplikowane rozwiązania techniczne, które\npoprzez warstwy opakowań i sztuczną izolację próbowały symulować idealny świat\nmikrofrontendów. Te rozwiązania przyniosły znaczące obciążenie wydajnościowe,\nkomplikując prosty rozwój i zaciemniając standardowe procesy.\n\n\nOgraniczenia tradycyjnych rozwiązań#\n\nW praktyce architektury mikrofrontendów doświadczyliśmy wielu ograniczeń\ntradycyjnych rozwiązań:\n\n * Straty wydajności: Wstrzykiwanie zależności w czasie wykonywania, proxy\n   piaskownicy JS, każda operacja pochłania cenną wydajność\n * Krucha izolacja: Sztucznie stworzone środowisko piaskownicy nigdy nie dorówna\n   natywnej izolacji przeglądarki\n * Złożoność budowania: Aby poradzić sobie z zależnościami, konieczne było\n   modyfikowanie narzędzi budujących, co utrudniało utrzymanie prostych\n   projektów\n * Niestandardowe reguły: Specjalne strategie wdrażania, przetwarzanie w czasie\n   wykonywania, każdy krok odbiegał od standardowych procesów współczesnego\n   rozwoju\n * Ograniczenia ekosystemu: Powiązanie z frameworkiem, niestandardowe API, co\n   zmuszało do wiązania się z określonym ekosystemem\n\nTe problemy były szczególnie widoczne w naszym projekcie korporacyjnym z 2019\nroku. Wówczas duży produkt został podzielony na kilkanaście niezależnych\npodsystemów biznesowych, które musiały współdzielić zestaw podstawowych i\nbiznesowych komponentów. Początkowo zastosowane rozwiązanie współdzielenia\nkomponentów oparte na pakietach npm ujawniło poważne problemy z efektywnością\nutrzymania: gdy współdzielony komponent był aktualizowany, wszystkie podsystemy\nzależne od tego komponentu musiały przejść pełny proces budowania i wdrażania.\n\n\nEwolucja technologiczna#\n\n\nv1.0: Eksploracja zdalnych komponentów#\n\nAby rozwiązać problem efektywności współdzielenia komponentów, Gez v1.0\nwprowadził mechanizm komponentów RemoteView oparty na protokole HTTP. To\nrozwiązanie, poprzez dynamiczne żądania w czasie wykonywania, umożliwiło\nskładanie kodu między usługami na żądanie, skutecznie rozwiązując problem zbyt\ndługiego łańcucha zależności budowania. Jednak ze względu na brak\nstandaryzowanego mechanizmu komunikacji w czasie wykonywania, synchronizacja\nstanu i przekazywanie zdarzeń między usługami nadal miały wąskie gardła\nwydajnościowe.\n\n\nv2.0: Próba federacji modułów#\n\nW wersji v2.0 zastosowaliśmy technologię federacji modułów (Module Federation) z\nWebpack 5.0. Ta technologia, poprzez ujednolicony mechanizm ładowania modułów i\nkontenery w czasie wykonywania, znacząco poprawiła efektywność współpracy między\nusługami. Jednak w praktyce na dużą skalę, zamknięty mechanizm implementacji\nfederacji modułów przyniósł nowe wyzwania: trudności w precyzyjnym zarządzaniu\nwersjami zależności, szczególnie przy ujednolicaniu współdzielonych zależności\nwielu usług, często napotykaliśmy konflikty wersji i wyjątki w czasie\nwykonywania.\n\n\nWkraczanie w nową erę ESM#\n\nPlanując wersję v3.0, dokładnie obserwowaliśmy trendy rozwoju ekosystemu\nfrontendu i zauważyliśmy, że postęp w natywnych możliwościach przeglądarek\notworzył nowe możliwości dla architektury mikrofrontendów:\n\n\nStandaryzowany system modułów#\n\nWraz z pełnym wsparciem głównych przeglądarek dla ES Modules oraz dojrzałością\nspecyfikacji Import Maps, rozwój frontendu wkroczył w prawdziwą erę\nmodularności. Według statystyk Can I Use, obecnie główne przeglądarki (Chrome >=\n89, Edge >= 89, Firefox >= 108, Safari >= 16.4) osiągnęły 93.5% natywnego\nwsparcia dla ESM, co zapewnia nam następujące korzyści:\n\n * Standaryzacja zarządzania zależnościami: Import Maps zapewnia możliwość\n   rozwiązywania zależności modułów na poziomie przeglądarki, bez potrzeby\n   skomplikowanego wstrzykiwania w czasie wykonywania\n * Optymalizacja ładowania zasobów: Natywny mechanizm buforowania modułów w\n   przeglądarce znacząco poprawia efektywność ładowania zasobów\n * Uproszczenie procesu budowania: Tryb rozwoju oparty na ESM sprawia, że\n   procesy budowania środowisk deweloperskich i produkcyjnych są bardziej spójne\n\nJednocześnie, dzięki wsparciu trybu kompatybilności (Chrome >= 87, Edge >= 88,\nFirefox >= 78, Safari >= 14), możemy zwiększyć zasięg przeglądarek do 96.81%, co\npozwala nam zachować wysoką wydajność bez rezygnacji z wsparcia dla starszych\nprzeglądarek.\n\n\nPrzełom w wydajności i izolacji#\n\nNatywny system modułów przyniósł nie tylko standaryzację, ale także znaczącą\npoprawę wydajności i izolacji:\n\n * Zero narzutu w czasie wykonywania: Pożegnanie z proxy piaskownicy JavaScript\n   i wstrzykiwaniem w czasie wykonywania w tradycyjnych rozwiązaniach\n   mikrofrontendów\n * Niezawodny mechanizm izolacji: Ścisły zakres modułów ESM naturalnie zapewnia\n   najbardziej niezawodną izolację\n * Precyzyjne zarządzanie zależnościami: Statyczna analiza importu sprawia, że\n   zależności są bardziej przejrzyste, a kontrola wersji bardziej precyzyjna\n\n\nWybór narzędzi budujących#\n\nW procesie wdrażania rozwiązania technologicznego, wybór narzędzi budujących był\nkluczową decyzją. Po prawie rocznych badaniach i praktyce, nasz wybór przeszedł\nnastępującą ewolucję:\n\n 1. Eksploracja Vite\n    \n    * Zalety: Serwer deweloperski oparty na ESM, zapewniający doskonałe\n      doświadczenie deweloperskie\n    * Wyzwania: Różnice w budowaniu środowisk deweloperskich i produkcyjnych\n      wprowadzały pewną niepewność\n\n 2. Ustalenie Rspack\n    \n    * Zalety wydajnościowe: Wysokowydajna kompilacja oparta na Rust, znacząco\n      poprawiająca szybkość budowania\n    * Wsparcie ekosystemu: Wysoka kompatybilność z ekosystemem Webpack,\n      obniżająca koszty migracji\n    * Wsparcie ESM: Praktyka projektu Rslib potwierdziła niezawodność w\n      budowaniu ESM\n\nTa decyzja pozwoliła nam zachować doświadczenie deweloperskie, jednocześnie\nzapewniając bardziej stabilne wsparcie dla środowiska produkcyjnego. Dzięki\nkombinacji ESM i Rspack, ostatecznie zbudowaliśmy wysokowydajne, mało inwazyjne\nrozwiązanie mikrofrontendów.\n\n\nPerspektywy na przyszłość#\n\nW przyszłych planach rozwoju framework Gez skupi się na następujących trzech\nkierunkach:\n\n\nGłęboka optymalizacja Import Maps#\n\n * Dynamiczne zarządzanie zależnościami: Inteligentne planowanie wersji\n   zależności w czasie wykonywania, rozwiązujące konflikty zależności między\n   wieloma aplikacjami\n * Strategie preładowania: Inteligentne preładowanie oparte na analizie\n   routingu, poprawiające efektywność ładowania zasobów\n * Optymalizacja budowania: Automatyczne generowanie optymalnej konfiguracji\n   Import Maps, redukujące koszty ręcznej konfiguracji przez deweloperów\n\n\nNiezależne od frameworka rozwiązanie routingu#\n\n * Abstrakcja ujednoliconego routingu: Projektowanie interfejsów routingu\n   niezależnych od frameworka, wspierających główne frameworki takie jak Vue,\n   React\n * Routing mikroaplikacji: Implementacja powiązań routingu między aplikacjami,\n   utrzymująca spójność URL i stanu aplikacji\n * Middleware routingu: Zapewnienie rozszerzalnego mechanizmu middleware,\n   wspierającego kontrolę dostępu, przejścia między stronami itp.\n\n\nNajlepsze praktyki komunikacji między frameworkami#\n\n * Przykładowe aplikacje: Dostarczenie kompletnych przykładów komunikacji między\n   frameworkami, obejmujących główne frameworki takie jak Vue, React, Preact\n * Synchronizacja stanu: Lekkie rozwiązanie współdzielenia stanu oparte na ESM\n * Szyna zdarzeń: Standaryzowany mechanizm komunikacji zdarzeń, wspierający\n   odłączoną komunikację między aplikacjami\n\nDzięki tym optymalizacjom i rozszerzeniom, oczekujemy, że Gez stanie się\nbardziej kompletnym i łatwym w użyciu rozwiązaniem mikrofrontendów,\nzapewniającym deweloperom lepsze doświadczenie i wyższą efektywność rozwoju.","routePath":"/pl/blog/birth-of-gez","lang":"pl","toc":[{"text":"Tło projektu","id":"tło-projektu","depth":2,"charIndex":104},{"text":"Ograniczenia tradycyjnych rozwiązań","id":"ograniczenia-tradycyjnych-rozwiązań","depth":3,"charIndex":494},{"text":"Ewolucja technologiczna","id":"ewolucja-technologiczna","depth":2,"charIndex":1878},{"text":"v1.0: Eksploracja zdalnych komponentów","id":"v10-eksploracja-zdalnych-komponentów","depth":3,"charIndex":1905},{"text":"v2.0: Próba federacji modułów","id":"v20-próba-federacji-modułów","depth":3,"charIndex":2475},{"text":"Wkraczanie w nową erę ESM","id":"wkraczanie-w-nową-erę-esm","depth":2,"charIndex":3069},{"text":"Standaryzowany system modułów","id":"standaryzowany-system-modułów","depth":3,"charIndex":3306},{"text":"Przełom w wydajności i izolacji","id":"przełom-w-wydajności-i-izolacji","depth":3,"charIndex":4451},{"text":"Wybór narzędzi budujących","id":"wybór-narzędzi-budujących","depth":3,"charIndex":5036},{"text":"Perspektywy na przyszłość","id":"perspektywy-na-przyszłość","depth":2,"charIndex":6096},{"text":"Głęboka optymalizacja Import Maps","id":"głęboka-optymalizacja-import-maps","depth":3,"charIndex":6215},{"text":"Niezależne od frameworka rozwiązanie routingu","id":"niezależne-od-frameworka-rozwiązanie-routingu","depth":3,"charIndex":6703},{"text":"Najlepsze praktyki komunikacji między frameworkami","id":"najlepsze-praktyki-komunikacji-między-frameworkami","depth":3,"charIndex":7179}],"domain":"","frontmatter":{"titleSuffix":"Od wyzwań mikrofrontendów do innowacji ESM: Droga ewolucji frameworka Gez","description":"Głęboka analiza ewolucji frameworka Gez od tradycyjnych architektur mikrofrontendów do innowacji opartych na ESM, dzielenie się praktycznymi doświadczeniami w optymalizacji wydajności, zarządzaniu zależnościami i wyborze narzędzi budujących.","head":[["meta",{"property":"keywords","content":"Gez, framework mikrofrontendów, ESM, Import Maps, Rspack, federacja modułów, zarządzanie zależnościami, optymalizacja wydajności, ewolucja technologiczna, renderowanie po stronie serwera"}]],"sidebar":false},"version":""},{"id":234,"title":"Blog zespołu","content":"#\n\nWitamy na blogu technicznym zespołu Gez! Tutaj dzielimy się doświadczeniami z\nprocesu rozwoju frameworków, innowacjami technologicznymi i najlepszymi\npraktykami.\n\n\nNajnowsze artykuły#\n\n * 2025-02-25 Od współdzielenia komponentów do natywnej modularyzacji: ewolucja\n   frameworku mikrofrontendowego Gez\n   \n   > Eksploracja ścieżki ewolucji frameworku Gez od tradycyjnego współdzielenia\n   > komponentów do natywnej modularyzacji opartej na ESM, dzielenie się\n   > praktycznymi doświadczeniami w optymalizacji wydajności, zarządzaniu\n   > zależnościami i wyborze narzędzi do budowania.","routePath":"/pl/blog/","lang":"pl","toc":[{"text":"Najnowsze artykuły","id":"najnowsze-artykuły","depth":2,"charIndex":166}],"domain":"","frontmatter":{"titleSuffix":"Blog zespołu Gez","description":"Blog techniczny zespołu Gez, dzielący się doświadczeniami w rozwoju frameworków, najlepszymi praktykami i innowacjami technologicznymi.","head":[["meta",{"property":"keywords","content":"Gez, blog zespołu, dzielenie się wiedzą techniczną, najlepsze praktyki, doświadczenia w rozwoju"}]],"sidebar":false},"version":""},{"id":235,"title":"Aliasy ścieżek","content":"#\n\nAlias ścieżki (Path Alias) to mechanizm mapowania ścieżek importu modułów, który\npozwala programistom używać krótkich, semantycznych identyfikatorów zamiast\npełnych ścieżek modułów. W Gez mechanizm aliasów ścieżek oferuje następujące\nkorzyści:\n\n * Uproszczenie ścieżek importu: Używanie semantycznych aliasów zamiast długich\n   ścieżek względnych, co zwiększa czytelność kodu\n * Unikanie głębokiego zagnieżdżenia: Eliminacja trudności w utrzymaniu\n   wynikających z wielopoziomowych odwołań do katalogów (np. ../../../../)\n * Bezpieczeństwo typów: Pełna integracja z systemem typów TypeScript,\n   zapewniająca uzupełnianie kodu i sprawdzanie typów\n * Optymalizacja rozpoznawania modułów: Poprawa wydajności rozpoznawania modułów\n   dzięki wstępnie zdefiniowanym mapowaniom ścieżek\n\n\nDomyślny mechanizm aliasów#\n\nGez wykorzystuje automatyczny mechanizm aliasów oparty na nazwie usługi (Service\nName), który charakteryzuje się następującymi cechami:\n\n * Automatyczna konfiguracja: Aliasy są generowane automatycznie na podstawie\n   pola name w package.json, bez konieczności ręcznej konfiguracji\n * Jednolita konwencja: Zapewnienie spójnej konwencji nazewnictwa i odwołań dla\n   wszystkich modułów usług\n * Wsparcie typów: W połączeniu z poleceniem npm run build:dts automatycznie\n   generowane są pliki deklaracji typów, umożliwiając wnioskowanie typów między\n   usługami\n * Przewidywalność: Możliwość wnioskowania ścieżki odwołania do modułu na\n   podstawie nazwy usługi, co zmniejsza koszty utrzymania\n\n\nKonfiguracja#\n\n\nKonfiguracja w package.json#\n\nW package.json nazwa usługi jest definiowana za pomocą pola name, które będzie\nużywane jako domyślny prefiks aliasu:\n\n\n\n\nKonfiguracja w tsconfig.json#\n\nAby TypeScript mógł poprawnie rozpoznawać ścieżki aliasów, należy skonfigurować\nmapowanie paths w tsconfig.json:\n\n\n\n\nPrzykłady użycia#\n\n\nImportowanie modułów wewnętrznych usługi#\n\n\n\n\nImportowanie modułów innych usług#\n\n\n\nNajlepsze praktyki\n * Preferuj używanie ścieżek aliasów zamiast ścieżek względnych\n * Zachowaj semantyczność i spójność ścieżek aliasów\n * Unikaj zbyt wielu poziomów katalogów w ścieżkach aliasów\n\n\n\n\nImportowanie między usługami#\n\nPo skonfigurowaniu łączenia modułów (Module Link) można użyć tej samej metody do\nimportowania modułów z innych usług:\n\n\n\n\nNiestandardowe aliasy#\n\nW przypadku pakietów stron trzecich lub specjalnych scenariuszy można\nskonfigurować niestandardowe aliasy za pomocą pliku konfiguracyjnego Gez:\n\n\n\nUwagi\n 1. Dla modułów biznesowych zaleca się zawsze używanie domyślnego mechanizmu\n    aliasów, aby zachować spójność projektu\n 2. Niestandardowe aliasy są głównie używane do obsługi specjalnych wymagań\n    pakietów stron trzecich lub optymalizacji doświadczenia programistycznego\n 3. Nadmierne używanie niestandardowych aliasów może wpłynąć na utrzymywalność\n    kodu i optymalizację budowania","routePath":"/pl/guide/essentials/alias","lang":"pl","toc":[{"text":"Domyślny mechanizm aliasów","id":"domyślny-mechanizm-aliasów","depth":2,"charIndex":785},{"text":"Konfiguracja","id":"konfiguracja","depth":2,"charIndex":1507},{"text":"Konfiguracja w package.json","id":"konfiguracja-w-packagejson","depth":3,"charIndex":1523},{"text":"Konfiguracja w tsconfig.json","id":"konfiguracja-w-tsconfigjson","depth":3,"charIndex":1674},{"text":"Przykłady użycia","id":"przykłady-użycia","depth":2,"charIndex":1822},{"text":"Importowanie modułów wewnętrznych usługi","id":"importowanie-modułów-wewnętrznych-usługi","depth":3,"charIndex":1842},{"text":"Importowanie modułów innych usług","id":"importowanie-modułów-innych-usług","depth":3,"charIndex":1888},{"text":"Importowanie między usługami","id":"importowanie-między-usługami","depth":3,"charIndex":2126},{"text":"Niestandardowe aliasy","id":"niestandardowe-aliasy","depth":3,"charIndex":2279}],"domain":"","frontmatter":{"titleSuffix":"Przewodnik po mapowaniu ścieżek importu modułów w Gez","description":"Szczegółowy opis mechanizmu aliasów ścieżek w Gez, w tym uproszczenie ścieżek importu, unikanie głębokiego zagnieżdżenia, bezpieczeństwo typów i optymalizacja rozpoznawania modułów, aby pomóc programistom w poprawie utrzymywalności kodu.","head":[["meta",{"property":"keywords","content":"Gez, aliasy ścieżek, Path Alias, TypeScript, import modułów, mapowanie ścieżek, utrzymywalność kodu"}]]},"version":""},{"id":236,"title":"Ścieżka bazowa","content":"#\n\nŚcieżka bazowa (Base Path) to prefiks ścieżki dostępu do zasobów statycznych\n(takich jak JavaScript, CSS, obrazy itp.) w aplikacji. W Gez odpowiednia\nkonfiguracja ścieżki bazowej jest kluczowa w następujących scenariuszach:\n\n * Wdrożenie w wielu środowiskach: Obsługa dostępu do zasobów w różnych\n   środowiskach, takich jak środowisko deweloperskie, testowe i produkcyjne\n * Wdrożenie w wielu regionach: Dostosowanie do wymagań wdrożenia klastrów w\n   różnych regionach lub krajach\n * Dystrybucja CDN: Realizacja globalnej dystrybucji i przyspieszenia zasobów\n   statycznych\n\n\nMechanizm domyślnej ścieżki#\n\nGez wykorzystuje automatyczny mechanizm generowania ścieżek oparty na nazwie\nusługi. Domyślnie framework odczytuje pole name z pliku package.json projektu,\naby wygenerować ścieżkę bazową dla zasobów statycznych: /your-app-name/.\n\n\n\nTen projekt oparty na konwencji ma następujące zalety:\n\n * Spójność: Zapewnia jednolity dostęp do wszystkich zasobów statycznych\n * Przewidywalność: Ścieżka dostępu do zasobów może być wywnioskowana na\n   podstawie pola name w pliku package.json\n * Łatwość utrzymania: Brak konieczności dodatkowej konfiguracji, co zmniejsza\n   koszty utrzymania\n\n\nKonfiguracja dynamicznej ścieżki#\n\nW rzeczywistych projektach często musimy wdrożyć ten sam kod w różnych\nśrodowiskach lub regionach. Gez zapewnia wsparcie dla dynamicznej ścieżki\nbazowej, co pozwala aplikacji dostosować się do różnych scenariuszy wdrożenia.\n\n\nScenariusze użycia#\n\nWdrożenie w podkatalogach#\n\n\n\nWdrożenie na niezależnych domenach#\n\n\n\n\nMetoda konfiguracji#\n\nPoprzez parametr base metody gez.render() można dynamicznie ustawić ścieżkę\nbazową na podstawie kontekstu żądania:\n\n","routePath":"/pl/guide/essentials/base-path","lang":"pl","toc":[{"text":"Mechanizm domyślnej ścieżki","id":"mechanizm-domyślnej-ścieżki","depth":2,"charIndex":580},{"text":"Konfiguracja dynamicznej ścieżki","id":"konfiguracja-dynamicznej-ścieżki","depth":2,"charIndex":1190},{"text":"Scenariusze użycia","id":"scenariusze-użycia","depth":3,"charIndex":1451},{"text":"Wdrożenie w podkatalogach","id":"wdrożenie-w-podkatalogach","depth":4,"charIndex":1472},{"text":"Wdrożenie na niezależnych domenach","id":"wdrożenie-na-niezależnych-domenach","depth":4,"charIndex":1502},{"text":"Metoda konfiguracji","id":"metoda-konfiguracji","depth":3,"charIndex":1542}],"domain":"","frontmatter":{"titleSuffix":"Przewodnik konfiguracji ścieżek zasobów statycznych w frameworku Gez","description":"Szczegółowy opis konfiguracji ścieżki bazowej w frameworku Gez, obejmujący wdrożenie w wielu środowiskach, dystrybucję CDN oraz ustawienia ścieżek dostępu do zasobów, pomagający programistom w elastycznym zarządzaniu zasobami statycznymi.","head":[["meta",{"property":"keywords","content":"Gez, Ścieżka bazowa, Base Path, CDN, Zasoby statyczne, Wdrożenie w wielu środowiskach, Zarządzanie zasobami"}]]},"version":""},{"id":237,"title":"Renderowanie po stronie klienta","content":"\n${rc.importmap()} // Mapowanie importów ${rc.moduleEntry()} // Moduł wejściowy\n${rc.modulePreload()} // Preładowanie modułów","routePath":"/pl/guide/essentials/csr","lang":"pl","toc":[{"text":"Scenariusze użycia","id":"scenariusze-użycia","depth":2,"charIndex":-1},{"text":"Konfiguracja","id":"konfiguracja","depth":2,"charIndex":-1},{"text":"Konfiguracja szablonu HTML","id":"konfiguracja-szablonu-html","depth":3,"charIndex":-1},{"text":"Generowanie statycznego HTML","id":"generowanie-statycznego-html","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Przewodnik implementacji renderowania po stronie klienta w frameworku Gez","description":"Szczegółowy opis mechanizmu renderowania po stronie klienta w frameworku Gez, w tym statyczna kompilacja, strategie wdrażania i najlepsze praktyki, pomagające programistom w osiągnięciu wydajnego renderowania frontendu w środowisku bezserwerowym.","head":[["meta",{"property":"keywords","content":"Gez, renderowanie po stronie klienta, CSR, statyczna kompilacja, renderowanie frontendu, wdrażanie bezserwerowe, optymalizacja wydajności"}]]},"version":""},{"id":238,"title":"Łączenie modułów","content":"#\n\nFramework Gez zapewnia kompleksowy mechanizm łączenia modułów, służący do\nzarządzania udostępnianiem kodu i zależnościami między usługami. Mechanizm ten\njest oparty na specyfikacji ESM (ECMAScript Module) i obsługuje eksportowanie\noraz importowanie modułów na poziomie kodu źródłowego, a także pełne zarządzanie\nzależnościami.\n\n\nKluczowe pojęcia#\n\nEksportowanie modułów#\n\nEksportowanie modułów to proces udostępniania określonych jednostek kodu (np.\nkomponentów, funkcji narzędziowych) z usługi w formacie ESM. Obsługiwane są dwa\ntypy eksportu:\n\n * Eksport kodu źródłowego: bezpośrednie eksportowanie plików źródłowych z\n   projektu\n * Eksport zależności: eksportowanie pakietów zależności innych firm używanych w\n   projekcie\n\nImportowanie modułów#\n\nImportowanie modułów to proces odwoływania się do jednostek kodu eksportowanych\nprzez inne usługi. Obsługiwane są różne metody instalacji:\n\n * Instalacja kodu źródłowego: odpowiednia dla środowisk deweloperskich,\n   obsługuje modyfikacje w czasie rzeczywistym i gorącą aktualizację\n * Instalacja pakietu: odpowiednia dla środowisk produkcyjnych, korzysta\n   bezpośrednio z wyników budowania\n\n\nMechanizm preładowania#\n\nW celu optymalizacji wydajności usług, Gez implementuje inteligentny mechanizm\npreładowania modułów:\n\n 1. Analiza zależności\n    \n    * Analiza zależności między komponentami podczas budowania\n    * Identyfikacja kluczowych modułów na ścieżce krytycznej\n    * Określenie priorytetów ładowania modułów\n\n 2. Strategie ładowania\n    \n    * Natychmiastowe ładowanie: kluczowe moduły na ścieżce krytycznej\n    * Opóźnione ładowanie: moduły funkcji niekrytycznych\n    * Ładowanie na żądanie: moduły renderowane warunkowo\n\n 3. Optymalizacja zasobów\n    \n    * Inteligentna strategia podziału kodu\n    * Zarządzanie pamięcią podręczną na poziomie modułów\n    * Kompilacja i pakowanie na żądanie\n\n\nEksportowanie modułów#\n\n\nKonfiguracja#\n\nKonfiguracja modułów do eksportu w pliku entry.node.ts:\n\n\n\nKonfiguracja eksportu obsługuje dwa typy:\n\n * root:*: eksportowanie plików źródłowych, ścieżka względem katalogu głównego\n   projektu\n * npm:*: eksportowanie zależności innych firm, bezpośrednie określenie nazwy\n   pakietu\n\n\nImportowanie modułów#\n\n\nKonfiguracja#\n\nKonfiguracja modułów do importu w pliku entry.node.ts:\n\n\n\nOpis konfiguracji:\n\n 1. imports: konfiguracja lokalnych ścieżek do modułów zdalnych\n    \n    * Instalacja kodu źródłowego: wskazuje na katalog wyników budowania (dist)\n    * Instalacja pakietu: bezpośrednio wskazuje na katalog pakietu\n\n 2. externals: konfiguracja zależności zewnętrznych\n    \n    * Służy do udostępniania zależności z modułów zdalnych\n    * Unika powtarzającego się pakowania tych samych zależności\n    * Obsługuje udostępnianie zależności przez wiele modułów\n\n\nMetody instalacji#\n\nInstalacja kodu źródłowego#\n\nOdpowiednia dla środowisk deweloperskich, obsługuje modyfikacje w czasie\nrzeczywistym i gorącą aktualizację.\n\n 1. Sposób Workspace Zalecany w projektach Monorepo:\n\n\n\n 2. Sposób Link Używany do lokalnego debugowania:\n\n\n\nInstalacja pakietu#\n\nOdpowiednia dla środowisk produkcyjnych, korzysta bezpośrednio z wyników\nbudowania.\n\n 1. Rejestr NPM Instalacja przez rejestr npm:\n\n\n\n 2. Serwer statyczny Instalacja przez protokół HTTP/HTTPS:\n\n\n\n\nBudowanie pakietów#\n\n\nKonfiguracja#\n\nKonfiguracja opcji budowania w pliku entry.node.ts:\n\n\n\n\nWyniki budowania#\n\n\n\n\nProces publikacji#\n\n\n\n\nNajlepsze praktyki#\n\n\nKonfiguracja środowiska deweloperskiego#\n\n * Zarządzanie zależnościami\n   \n   * Używanie sposobu Workspace lub Link do instalacji zależności\n   * Ujednolicone zarządzanie wersjami zależności\n   * Unikanie powtarzającej się instalacji tych samych zależności\n\n * Doświadczenie deweloperskie\n   \n   * Włączanie funkcji gorącej aktualizacji\n   * Konfiguracja odpowiednich strategii preładowania\n   * Optymalizacja szybkości budowania\n\n\nKonfiguracja środowiska produkcyjnego#\n\n * Strategie wdrażania\n   \n   * Używanie rejestru NPM lub serwera statycznego\n   * Zapewnienie integralności wyników budowania\n   * Wdrażanie mechanizmu stopniowego udostępniania\n\n * Optymalizacja wydajności\n   \n   * Odpowiednia konfiguracja preładowania zasobów\n   * Optymalizacja kolejności ładowania modułów\n   * Wdrażanie efektywnych strategii pamięci podręcznej\n\n\nZarządzanie wersjami#\n\n * Standardy wersjonowania\n   \n   * Przestrzeganie semantycznego wersjonowania\n   * Utrzymywanie szczegółowych dzienników zmian\n   * Przeprowadzanie testów zgodności wersji\n\n * Aktualizacja zależności\n   \n   * Regularne aktualizowanie pakietów zależności\n   * Przeprowadzanie okresowych audytów bezpieczeństwa\n   * Utrzymywanie spójności wersji zależności\n\n","routePath":"/pl/guide/essentials/module-link","lang":"pl","toc":[{"text":"Kluczowe pojęcia","id":"kluczowe-pojęcia","depth":3,"charIndex":331},{"text":"Eksportowanie modułów","id":"eksportowanie-modułów","depth":4,"charIndex":350},{"text":"Importowanie modułów","id":"importowanie-modułów","depth":4,"charIndex":730},{"text":"Mechanizm preładowania","id":"mechanizm-preładowania","depth":3,"charIndex":1146},{"text":"Eksportowanie modułów","id":"eksportowanie-modułów-1","depth":2,"charIndex":1860},{"text":"Konfiguracja","id":"konfiguracja","depth":3,"charIndex":1885},{"text":"Importowanie modułów","id":"importowanie-modułów-1","depth":2,"charIndex":2184},{"text":"Konfiguracja","id":"konfiguracja-1","depth":3,"charIndex":2208},{"text":"Metody instalacji","id":"metody-instalacji","depth":3,"charIndex":2760},{"text":"Instalacja kodu źródłowego","id":"instalacja-kodu-źródłowego","depth":4,"charIndex":2780},{"text":"Instalacja pakietu","id":"instalacja-pakietu","depth":4,"charIndex":3028},{"text":"Budowanie pakietów","id":"budowanie-pakietów","depth":2,"charIndex":3246},{"text":"Konfiguracja","id":"konfiguracja-2","depth":3,"charIndex":3268},{"text":"Wyniki budowania","id":"wyniki-budowania","depth":3,"charIndex":3339},{"text":"Proces publikacji","id":"proces-publikacji","depth":3,"charIndex":3361},{"text":"Najlepsze praktyki","id":"najlepsze-praktyki","depth":2,"charIndex":3384},{"text":"Konfiguracja środowiska deweloperskiego","id":"konfiguracja-środowiska-deweloperskiego","depth":3,"charIndex":3406},{"text":"Konfiguracja środowiska produkcyjnego","id":"konfiguracja-środowiska-produkcyjnego","depth":3,"charIndex":3838},{"text":"Zarządzanie wersjami","id":"zarządzanie-wersjami","depth":3,"charIndex":4247}],"domain":"","frontmatter":{"titleSuffix":"Mechanizm udostępniania kodu między usługami w frameworku Gez","description":"Szczegółowy opis mechanizmu łączenia modułów w frameworku Gez, w tym udostępniania kodu między usługami, zarządzania zależnościami i implementacji specyfikacji ESM, pomagający programistom w budowaniu wydajnych aplikacji mikrofrontendowych.","head":[["meta",{"property":"keywords","content":"Gez, łączenie modułów, Module Link, ESM, udostępnianie kodu, zarządzanie zależnościami, mikrofrontendy"}]]},"version":""},{"id":239,"title":"Kontekst renderowania","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/pl/guide/essentials/render-context","lang":"pl","toc":[{"text":"Sposób użycia","id":"sposób-użycia","depth":2,"charIndex":-1},{"text":"Główne funkcje","id":"główne-funkcje","depth":2,"charIndex":-1},{"text":"Zbieranie zależności","id":"zbieranie-zależności","depth":3,"charIndex":-1},{"text":"Zbieranie na żądanie","id":"zbieranie-na-żądanie","depth":4,"charIndex":-1},{"text":"Automatyczne przetwarzanie","id":"automatyczne-przetwarzanie","depth":4,"charIndex":-1},{"text":"Optymalizacja wydajności","id":"optymalizacja-wydajności","depth":4,"charIndex":-1},{"text":"Wstrzykiwanie zasobów","id":"wstrzykiwanie-zasobów","depth":3,"charIndex":-1},{"text":"Kolejność wstrzykiwania zasobów","id":"kolejność-wstrzykiwania-zasobów","depth":3,"charIndex":-1},{"text":"Pełny proces renderowania","id":"pełny-proces-renderowania","depth":2,"charIndex":-1},{"text":"Zaawansowane funkcje","id":"zaawansowane-funkcje","depth":2,"charIndex":-1},{"text":"Konfiguracja ścieżki bazowej","id":"konfiguracja-ścieżki-bazowej","depth":3,"charIndex":-1},{"text":"Tryby mapowania importu","id":"tryby-mapowania-importu","depth":3,"charIndex":-1},{"text":"Konfiguracja funkcji wejściowej","id":"konfiguracja-funkcji-wejściowej","depth":3,"charIndex":-1},{"text":"Najlepsze praktyki","id":"najlepsze-praktyki","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Mechanizmy renderowania po stronie serwera w frameworku Gez","description":"Szczegółowy opis mechanizmu kontekstu renderowania (RenderContext) w frameworku Gez, obejmujący zarządzanie zasobami, generowanie HTML oraz system modułów ESM, pomagający programistom zrozumieć i wykorzystać funkcje renderowania po stronie serwera.","head":[["meta",{"property":"keywords","content":"Gez, kontekst renderowania, RenderContext, SSR, renderowanie po stronie serwera, ESM, zarządzanie zasobami"}]]},"version":""},{"id":240,"title":"Rspack","content":"#\n\nGez opiera się na systemie budowania Rspack, w pełni wykorzystując jego\nwysokowydajne możliwości budowania. Ten dokument przedstawia rolę i kluczowe\nfunkcje Rspack w frameworku Gez.\n\n\nFunkcje#\n\nRspack jest podstawowym systemem budowania frameworku Gez, oferując następujące\nkluczowe funkcje:\n\n * Wysokowydajne budowanie: Silnik budowania oparty na Rust, zapewniający\n   błyskawiczną kompilację, znacząco przyspieszając budowanie dużych projektów\n * Optymalizacja doświadczenia programistycznego: Obsługa hot reload (HMR),\n   kompilacja przyrostowa i inne nowoczesne funkcje programistyczne, zapewniając\n   płynne doświadczenie programistyczne\n * Budowanie w wielu środowiskach: Ujednolicone konfiguracje budowania\n   obsługujące środowiska klienckie (client), serwerowe (server) i Node.js\n   (node), upraszczając proces rozwoju wieloplatformowego\n * Optymalizacja zasobów: Wbudowane możliwości przetwarzania i optymalizacji\n   zasobów, obsługa podziału kodu, Tree Shaking, kompresji zasobów i innych\n   funkcji\n\n\nBudowanie aplikacji#\n\nSystem budowania Rspack w Gez ma modułową strukturę i obejmuje następujące\nkluczowe moduły:\n\n\n@gez/rspack#\n\nPodstawowy moduł budowania, zapewniający następujące kluczowe możliwości:\n\n * Ujednolicone konfiguracje budowania: Zapewnia standaryzowane zarządzanie\n   konfiguracjami budowania, obsługujące konfiguracje dla wielu środowisk\n * Przetwarzanie zasobów: Wbudowane możliwości przetwarzania zasobów takich jak\n   TypeScript, CSS, obrazy itp.\n * Optymalizacja budowania: Zapewnia funkcje optymalizacji wydajności, takie jak\n   podział kodu i Tree Shaking\n * Serwer programistyczny: Zintegrowany wysokowydajny serwer programistyczny z\n   obsługą HMR\n\n\n@gez/rspack-vue#\n\nSpecjalny moduł budowania dla frameworku Vue, zapewniający:\n\n * Kompilacja komponentów Vue: Obsługa wydajnej kompilacji komponentów Vue 2/3\n * Optymalizacja SSR: Specyficzne optymalizacje dla scenariuszy renderowania po\n   stronie serwera\n * Rozszerzenia programistyczne: Specyficzne funkcje rozszerzające środowisko\n   programistyczne Vue\n\n\nProces budowania#\n\nProces budowania w Gez składa się z następujących etapów:\n\n 1. Inicjalizacja konfiguracji\n    \n    * Ładowanie konfiguracji projektu\n    * Scalanie konfiguracji domyślnych i użytkownika\n    * Dostosowanie konfiguracji na podstawie zmiennych środowiskowych\n\n 2. Kompilacja zasobów\n    \n    * Analiza zależności kodu źródłowego\n    * Transformacja różnych zasobów (TypeScript, CSS itp.)\n    * Przetwarzanie importów i eksportów modułów\n\n 3. Przetwarzanie optymalizacji\n    \n    * Wykonanie podziału kodu\n    * Zastosowanie Tree Shaking\n    * Kompresja kodu i zasobów\n\n 4. Generowanie wyników\n    \n    * Generowanie plików docelowych\n    * Generowanie map zasobów\n    * Generowanie raportu budowania\n\n\nNajlepsze praktyki#\n\n\nOptymalizacja środowiska programistycznego#\n\n * Konfiguracja kompilacji przyrostowej: Właściwa konfiguracja opcji cache,\n   wykorzystanie pamięci podręcznej do przyspieszenia budowania\n * Optymalizacja HMR: Celowa konfiguracja zakresu hot reload, unikanie\n   niepotrzebnych aktualizacji modułów\n * Optymalizacja przetwarzania zasobów: Używanie odpowiednich konfiguracji\n   loaderów, unikanie powtarzającego się przetwarzania\n\n\nOptymalizacja środowiska produkcyjnego#\n\n * Strategia podziału kodu: Właściwa konfiguracja splitChunks, optymalizacja\n   ładowania zasobów\n * Kompresja zasobów: Włączenie odpowiednich konfiguracji kompresji,\n   równoważenie czasu budowania i rozmiaru wyników\n * Optymalizacja pamięci podręcznej: Wykorzystanie skrótów zawartości i\n   strategii długoterminowego buforowania, poprawa wydajności ładowania\n\n\nPrzykład konfiguracji#\n\n\n\nTIP\n\nWięcej szczegółowych informacji na temat API i opcji konfiguracji można znaleźć\nw dokumentacji API Rspack.","routePath":"/pl/guide/essentials/rspack","lang":"pl","toc":[{"text":"Funkcje","id":"funkcje","depth":2,"charIndex":186},{"text":"Budowanie aplikacji","id":"budowanie-aplikacji","depth":2,"charIndex":1015},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":1131},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":1690},{"text":"Proces budowania","id":"proces-budowania","depth":2,"charIndex":2050},{"text":"Najlepsze praktyki","id":"najlepsze-praktyki","depth":2,"charIndex":2768},{"text":"Optymalizacja środowiska programistycznego","id":"optymalizacja-środowiska-programistycznego","depth":3,"charIndex":2790},{"text":"Optymalizacja środowiska produkcyjnego","id":"optymalizacja-środowiska-produkcyjnego","depth":3,"charIndex":3217},{"text":"Przykład konfiguracji","id":"przykład-konfiguracji","depth":2,"charIndex":3622}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework - Wysokowydajny silnik budowania","description":"Szczegółowa analiza systemu budowania Rspack w frameworku Gez, obejmująca kluczowe funkcje takie jak wysokowydajna kompilacja, budowanie w wielu środowiskach, optymalizacja zasobów, które pomagają programistom tworzyć wydajne i niezawodne nowoczesne aplikacje webowe.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, system budowania, wysokowydajna kompilacja, hot reload, budowanie w wielu środowiskach, Tree Shaking, podział kodu, SSR, optymalizacja zasobów, efektywność programistyczna, narzędzia budowania"}]]},"version":""},{"id":241,"title":"Standardy","content":"#\n\nGez to nowoczesny framework SSR, który wykorzystuje znormalizowaną strukturę\nprojektu i mechanizmy rozwiązywania ścieżek, aby zapewnić spójność i łatwość\nutrzymania projektu zarówno w środowiskach deweloperskich, jak i produkcyjnych.\n\n\nStandardy struktury projektu#\n\n\nStandardowa struktura katalogów#\n\n\n\nWiedza dodatkowa\n * gez.name pochodzi z pola name w package.json\n * dist/package.json pochodzi z package.json w katalogu głównym\n * Katalog dist jest archiwizowany tylko wtedy, gdy packs.enable jest ustawione\n   na true\n\n\nStandardy plików wejściowych#\n\n\nentry.client.ts#\n\nPlik wejściowy klienta odpowiada za:\n\n * Inicjalizację aplikacji: Konfiguracja podstawowych ustawień aplikacji\n   klienckiej\n * Zarządzanie routingiem: Obsługa routingu i nawigacji klienta\n * Zarządzanie stanem: Implementacja przechowywania i aktualizacji stanu klienta\n * Obsługa interakcji: Zarządzanie zdarzeniami użytkownika i interakcjami\n   interfejsu\n\n\nentry.server.ts#\n\nPlik wejściowy serwera odpowiada za:\n\n * Renderowanie po stronie serwera: Wykonanie procesu renderowania SSR\n * Generowanie HTML: Budowanie struktury początkowej strony\n * Pobieranie danych: Obsługa pobierania danych po stronie serwera\n * Wstrzykiwanie stanu: Przekazywanie stanu serwera do klienta\n * Optymalizacja SEO: Zapewnienie optymalizacji pod kątem wyszukiwarek\n\n\nentry.node.ts#\n\nPlik wejściowy serwera Node.js odpowiada za:\n\n * Konfigurację serwera: Ustawianie parametrów serwera HTTP\n * Obsługę routingu: Zarządzanie regułami routingu serwera\n * Integrację middleware: Konfiguracja middleware serwera\n * Zarządzanie środowiskiem: Obsługa zmiennych środowiskowych i konfiguracji\n * Obsługę żądań i odpowiedzi: Obsługa żądań i odpowiedzi HTTP\n\n\nStandardy plików konfiguracyjnych#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/pl/guide/essentials/std","lang":"pl","toc":[{"text":"Standardy struktury projektu","id":"standardy-struktury-projektu","depth":2,"charIndex":238},{"text":"Standardowa struktura katalogów","id":"standardowa-struktura-katalogów","depth":3,"charIndex":270},{"text":"Standardy plików wejściowych","id":"standardy-plików-wejściowych","depth":2,"charIndex":528},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":560},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":938},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":1328},{"text":"Standardy plików konfiguracyjnych","id":"standardy-plików-konfiguracyjnych","depth":2,"charIndex":1709},{"text":"package.json","id":"packagejson","depth":3,"charIndex":1746},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":1764}],"domain":"","frontmatter":{"titleSuffix":"Przewodnik po strukturze i standardach projektu frameworku Gez","description":"Szczegółowy opis standardowej struktury projektu, specyfikacji plików wejściowych i konfiguracji frameworku Gez, pomagający programistom w budowaniu znormalizowanych i łatwych w utrzymaniu aplikacji SSR.","head":[["meta",{"property":"keywords","content":"Gez, struktura projektu, plik wejściowy, specyfikacja konfiguracji, framework SSR, TypeScript, standardy projektu, standardy rozwoju"}]]},"version":""},{"id":242,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/pl/guide/frameworks/html","lang":"pl","toc":[{"text":"Struktura projektu","id":"struktura-projektu","depth":2,"charIndex":-1},{"text":"Konfiguracja projektu","id":"konfiguracja-projektu","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Struktura kodu źródłowego","id":"struktura-kodu-źródłowego","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Uruchomienie projektu","id":"uruchomienie-projektu","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Przykład aplikacji HTML SSR w frameworku Gez","description":"Przewodnik krok po kroku dotyczący tworzenia aplikacji HTML SSR opartej na Gez, prezentujący podstawowe użycie frameworku, w tym inicjalizację projektu, konfigurację HTML i ustawienia plików wejściowych.","head":[["meta",{"property":"keywords","content":"Gez, HTML, Aplikacja SSR, Konfiguracja TypeScript, Inicjalizacja projektu, Renderowanie po stronie serwera, Interakcja po stronie klienta"}]]},"version":""},{"id":243,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/pl/guide/frameworks/preact-htm","lang":"pl","toc":[{"text":"Struktura projektu","id":"struktura-projektu","depth":2,"charIndex":-1},{"text":"Konfiguracja projektu","id":"konfiguracja-projektu","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Struktura kodu źródłowego","id":"struktura-kodu-źródłowego","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Uruchomienie projektu","id":"uruchomienie-projektu","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Przykład aplikacji Preact+HTM SSR w frameworku Gez","description":"Tworzenie aplikacji Preact+HTM SSR od podstaw z wykorzystaniem frameworku Gez. Przykład pokazuje podstawowe użycie frameworku, w tym inicjalizację projektu, konfigurację Preact i ustawienia plików wejściowych.","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, aplikacja SSR, konfiguracja TypeScript, inicjalizacja projektu, renderowanie po stronie serwera, interakcja po stronie klienta"}]]},"version":""},{"id":244,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/pl/guide/frameworks/vue2","lang":"pl","toc":[{"text":"Struktura projektu","id":"struktura-projektu","depth":2,"charIndex":-1},{"text":"Konfiguracja projektu","id":"konfiguracja-projektu","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Struktura kodu źródłowego","id":"struktura-kodu-źródłowego","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Uruchomienie projektu","id":"uruchomienie-projektu","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Przykład aplikacji Vue2 SSR w frameworku Gez","description":"Tworzenie aplikacji Vue2 SSR opartej na Gez od podstaw, prezentujące podstawowe użycie frameworku, w tym inicjalizację projektu, konfigurację Vue2 i ustawienia plików wejściowych.","head":[["meta",{"property":"keywords","content":"Gez, Vue2, aplikacja SSR, konfiguracja TypeScript, inicjalizacja projektu, renderowanie po stronie serwera, interakcja po stronie klienta"}]]},"version":""},{"id":245,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/pl/guide/frameworks/vue3","lang":"pl","toc":[{"text":"Struktura projektu","id":"struktura-projektu","depth":2,"charIndex":-1},{"text":"Konfiguracja projektu","id":"konfiguracja-projektu","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Struktura kodu źródłowego","id":"struktura-kodu-źródłowego","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Uruchomienie projektu","id":"uruchomienie-projektu","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Przykład aplikacji Vue3 SSR w frameworku Gez","description":"Tworzenie aplikacji Vue3 SSR opartej na Gez od podstaw, prezentujące podstawowe użycie frameworku, w tym inicjalizację projektu, konfigurację Vue3 i ustawienia plików wejściowych.","head":[["meta",{"property":"keywords","content":"Gez, Vue3, aplikacja SSR, konfiguracja TypeScript, inicjalizacja projektu, renderowanie po stronie serwera, interakcja po stronie klienta, API kompozycyjne"}]]},"version":""},{"id":246,"title":"Wymagania środowiskowe","content":"#\n\nTen dokument opisuje wymagania środowiskowe niezbędne do korzystania z tego\nframeworka, w tym środowisko Node.js i kompatybilność przeglądarek.\n\n\nŚrodowisko Node.js#\n\nFramework wymaga wersji Node.js >= 22.6, głównie w celu obsługi importu typów\nTypeScript (poprzez flagę --experimental-strip-types), bez konieczności\ndodatkowych kroków kompilacji.\n\n\nKompatybilność przeglądarek#\n\nFramework domyślnie jest budowany w trybie kompatybilności, aby obsługiwać\nszerszy zakres przeglądarek. Należy jednak pamiętać, że aby uzyskać pełne\nwsparcie kompatybilności przeglądarek, należy ręcznie dodać zależność\nes-module-shims.\n\n\nTryb kompatybilności (domyślny)#\n\n * 🌐 Chrome: >= 87\n * 🔷 Edge: >= 88\n * 🦊 Firefox: >= 78\n * 🧭 Safari: >= 14\n\nZgodnie z danymi z Can I Use, pokrycie przeglądarek w trybie kompatybilności\nwynosi 96,81%.\n\n\nTryb natywnego wsparcia#\n\n * 🌐 Chrome: >= 89\n * 🔷 Edge: >= 89\n * 🦊 Firefox: >= 108\n * 🧭 Safari: >= 16.4\n\nTryb natywnego wsparcia oferuje następujące korzyści:\n\n * Zero narzutu czasu wykonania, bez dodatkowego modułu ładującego\n * Natywne parsowanie przez przeglądarkę, szybsza wydajność\n * Lepsze możliwości podziału kodu i ładowania na żądanie\n\nZgodnie z danymi z Can I Use, pokrycie przeglądarek w trybie natywnego wsparcia\nwynosi 93,5%.\n\n\nWłączanie wsparcia kompatybilności#\n\nWażna uwaga\n\nChociaż framework domyślnie jest budowany w trybie kompatybilności, aby uzyskać\npełne wsparcie dla starszych przeglądarek, należy dodać zależność\nes-module-shims do projektu.\n\nDodaj następujący skrypt do pliku HTML:\n\n\n\nNajlepsze praktyki\n 1. Zalecenia dla środowiska produkcyjnego:\n    * Wdróż es-module-shims na własnym serwerze\n    * Zapewnij stabilność i szybkość ładowania zasobów\n    * Unikaj potencjalnych zagrożeń bezpieczeństwa\n 2. Rozważania dotyczące wydajności:\n    * Tryb kompatybilności wprowadza niewielki narzut wydajności\n    * Można zdecydować o włączeniu na podstawie rozkładu przeglądarek wśród\n      docelowych użytkowników","routePath":"/pl/guide/start/environment","lang":"pl","toc":[{"text":"Środowisko Node.js","id":"środowisko-nodejs","depth":2,"charIndex":148},{"text":"Kompatybilność przeglądarek","id":"kompatybilność-przeglądarek","depth":2,"charIndex":352},{"text":"Tryb kompatybilności (domyślny)","id":"tryb-kompatybilności-domyślny","depth":3,"charIndex":620},{"text":"Tryb natywnego wsparcia","id":"tryb-natywnego-wsparcia","depth":3,"charIndex":828},{"text":"Włączanie wsparcia kompatybilności","id":"włączanie-wsparcia-kompatybilności","depth":3,"charIndex":1274}],"domain":"","frontmatter":{"titleSuffix":"Przewodnik zgodności frameworka Gez","description":"Szczegółowy opis wymagań środowiskowych frameworka Gez, w tym wymagań dotyczących wersji Node.js i kompatybilności przeglądarek, aby pomóc programistom w prawidłowej konfiguracji środowiska deweloperskiego.","head":[["meta",{"property":"keywords","content":"Gez, Node.js, kompatybilność przeglądarek, TypeScript, es-module-shims, konfiguracja środowiska"}]]},"version":""},{"id":247,"title":"Szybki start","content":"#\n\n\nInicjalizacja projektu#\n\nAby utworzyć i zainicjować nowy projekt Gez, wykonaj następujące kroki:\n\n\n\n\nWybór wersji frameworka#\n\nFramework Gez oferuje wiele wersji stosu technologicznego, z których każda jest\nzoptymalizowana pod kątem różnych scenariuszy aplikacyjnych. Wybierz odpowiednią\nwersję zgodnie z wymaganiami projektu:\n\n\nHTML#\n\nOdpowiedni dla projektów dążących do minimalnej architektury:\n\n * Zero zależności zewnętrznych, gotowy do użycia od razu\n * Natywne doświadczenie rozwoju w JavaScript\n * Idealny do budowania statycznych stron internetowych i lekkich aplikacji\n * Wsparcie dla stopniowego rozszerzania funkcjonalności\n\nZobacz szczegółową dokumentację wersji HTML\n\n\nVue2#\n\nOdpowiedni dla rozwoju aplikacji na poziomie przedsiębiorstwa:\n\n * Pełne wsparcie dla TypeScript\n * Bogaty ekosystem komponentów stron trzecich\n * Dojrzały łańcuch narzędzi deweloperskich\n * Sprawdzona stabilność w środowisku produkcyjnym\n\nZobacz szczegółową dokumentację wersji Vue2\n\n\nVue3#\n\nOdpowiedni dla nowoczesnych aplikacji webowych:\n\n * System reaktywności oparty na Proxy\n * Wsparcie dla API kompozycyjnego\n * Lepsza wydajność w czasie wykonywania\n * Mniejszy rozmiar pakietu\n\nZobacz szczegółową dokumentację wersji Vue3\n\n\nPreact+HTM#\n\nOdpowiedni dla projektów dążących do lekkości i wysokiej wydajności:\n\n * Bardzo mały rozmiar środowiska uruchomieniowego (3KB)\n * Natywna składnia szablonów JavaScript\n * API kompatybilne z React\n * Doskonała wydajność\n\nZobacz szczegółową dokumentację wersji Preact+HTM\n\n\nWsparcie AI w rozwoju#\n\nFramework Gez oferuje możliwości wsparcia AI w rozwoju, co może znacząco\nzwiększyć efektywność:\n\n 1. Wybierz odpowiednią dokumentację wersji frameworka\n 2. Przekaż treść dokumentacji do asystenta AI\n 3. AI automatycznie wygeneruje szkielet projektu i pliki konfiguracyjne\n\nWskazówka\n\nWsparcie AI w rozwoju nie tylko przyspiesza inicjalizację projektu, ale także\nzapewnia, że struktura projektu jest zgodna z najlepszymi praktykami.","routePath":"/pl/guide/start/getting-started","lang":"pl","toc":[{"text":"Inicjalizacja projektu","id":"inicjalizacja-projektu","depth":2,"charIndex":3},{"text":"Wybór wersji frameworka","id":"wybór-wersji-frameworka","depth":2,"charIndex":104},{"text":"HTML","id":"html","depth":3,"charIndex":332},{"text":"Vue2","id":"vue2","depth":3,"charIndex":686},{"text":"Vue3","id":"vue3","depth":3,"charIndex":979},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":1225},{"text":"Wsparcie AI w rozwoju","id":"wsparcie-ai-w-rozwoju","depth":2,"charIndex":1510}],"domain":"","frontmatter":{"titleSuffix":"Przewodnik szybkiego startu frameworka Gez","description":"Przewodnik szybkiego startu frameworka Gez, który pomoże Ci rozpocząć projekt od zera, obejmujący inicjalizację projektu, wybór wersji frameworka oraz wsparcie AI w rozwoju.","head":[["meta",{"name":"keywords","content":"Framework Gez, Szybki start, Inicjalizacja projektu, Rozwój Vue, Rozwój HTML, Wsparcie AI"}]]},"version":""},{"id":248,"title":"Wprowadzenie","content":"#\n\n\nTło projektu#\n\nGez to nowoczesny framework mikrofrontendowy oparty na ECMAScript Modules (ESM),\nskupiający się na budowaniu wydajnych i skalowalnych aplikacji z renderowaniem\npo stronie serwera (SSR). Jako trzecia generacja projektu Genesis, Gez stale\nwprowadza innowacje w procesie ewolucji technologicznej:\n\n * v1.0: Implementacja ładowania komponentów zdalnych na żądanie za pomocą żądań\n   HTTP\n * v2.0: Integracja aplikacji za pomocą Webpack Module Federation\n * v3.0: Przeprojektowanie systemu łączenia modułów w oparciu o natywny ESM w\n   przeglądarce\n\n\nTło technologiczne#\n\nW trakcie rozwoju architektury mikrofrontendowej tradycyjne rozwiązania\nnapotkały następujące ograniczenia:\n\n\nWyzwania istniejących rozwiązań#\n\n * Wąskie gardła wydajnościowe: Wstrzykiwanie zależności w czasie wykonywania i\n   proxy piaskownicy JavaScript powodują znaczne obciążenie wydajnościowe\n * Mechanizmy izolacji: Własne środowiska piaskownicowe nie dorównują natywnym\n   możliwościom izolacji modułów w przeglądarce\n * Złożoność budowania: Modyfikacje narzędzi do budowania w celu udostępniania\n   zależności zwiększają koszty utrzymania projektu\n * Odchylenie od standardów: Specjalne strategie wdrażania i mechanizmy\n   przetwarzania w czasie wykonywania odbiegają od współczesnych standardów\n   rozwoju webowego\n * Ograniczenia ekosystemu: Powiązanie z frameworkiem i niestandardowe API\n   ograniczają wybór stosu technologicznego\n\n\nInnowacje technologiczne#\n\nGez, oparty na współczesnych standardach webowych, oferuje nowe rozwiązania:\n\n * Natywny system modułów: Wykorzystanie natywnego ESM i Import Maps w\n   przeglądarce do zarządzania zależnościami, zapewniając szybsze parsowanie i\n   wykonywanie\n * Standardowe mechanizmy izolacji: Niezawodna izolacja aplikacji oparta na\n   zakresie modułów ECMAScript\n * Otwarty stos technologiczny: Obsługa bezproblemowej integracji z dowolnym\n   nowoczesnym frameworkiem frontendowym\n * Optymalizacja doświadczenia developerskiego: Intuicyjne modele\n   programistyczne i pełne możliwości debugowania\n * Ekstremalna optymalizacja wydajności: Zerowy narzut w czasie wykonywania\n   dzięki wykorzystaniu natywnych możliwości, w połączeniu z inteligentnymi\n   strategiami buforowania\n\nTIP\n\nGez koncentruje się na budowaniu wysokowydajnej i łatwo skalowalnej\ninfrastruktury mikrofrontendowej, szczególnie odpowiedniej dla aplikacji z\nrenderowaniem po stronie serwera na dużą skalę.\n\n\nSpecyfikacja techniczna#\n\n\nWymagania środowiskowe#\n\nZapoznaj się z dokumentacją wymagań środowiskowych, aby poznać szczegółowe\nwymagania dotyczące przeglądarki i środowiska Node.js.\n\n\nKluczowy stos technologiczny#\n\n * Zarządzanie zależnościami: Wykorzystanie Import Maps do mapowania modułów, z\n   obsługą zgodności zapewnianą przez es-module-shims\n * System budowania: Przetwarzanie zależności zewnętrznych za pomocą\n   module-import opartego na Rspack\n * Łańcuch narzędzi developerskich: Obsługa gorącego przeładowania ESM i\n   natywnego wykonywania TypeScript\n\n\nPozycjonowanie frameworka#\n\nGez różni się od Next.js czy Nuxt.js, koncentrując się na dostarczaniu\ninfrastruktury mikrofrontendowej:\n\n * System łączenia modułów: Efektywne i niezawodne importowanie i eksportowanie\n   modułów\n * Renderowanie po stronie serwera: Elastyczne mechanizmy implementacji SSR\n * Obsługa systemu typów: Pełna integracja z definicjami typów TypeScript\n * Niezależność od frameworka: Obsługa integracji z głównymi frameworkami\n   frontendowymi\n\n\nProjekt architektoniczny#\n\n\nCentralizowane zarządzanie zależnościami#\n\n * Ujednolicone źródło zależności: Centralizowane zarządzanie zależnościami\n   stron trzecich\n * Automatyczna dystrybucja: Globalna automatyczna synchronizacja aktualizacji\n   zależności\n * Spójność wersji: Precyzyjna kontrola wersji zależności\n\n\nProjekt modułowy#\n\n * Rozdzielenie obowiązków: Oddzielenie logiki biznesowej od infrastruktury\n * Mechanizm wtyczek: Obsługa elastycznego łączenia i wymiany modułów\n * Standardowe interfejsy: Znormalizowane protokoły komunikacji między modułami\n\n\nOptymalizacja wydajności#\n\n * Zasada zerowego narzutu: Maksymalne wykorzystanie natywnych możliwości\n   przeglądarki\n * Inteligentne buforowanie: Precyzyjne strategie buforowania oparte na skrótach\n   zawartości\n * Ładowanie na żądanie: Szczegółowe dzielenie kodu i zarządzanie zależnościami\n\n\nDojrzałość projektu#\n\nGez, po prawie 5 latach iteracyjnego rozwoju (od v1.0 do v3.0), został\nkompleksowo zweryfikowany w środowiskach korporacyjnych. Obecnie wspiera\nstabilne działanie dziesiątek projektów biznesowych i stale napędza modernizację\nstosu technologicznego. Stabilność, niezawodność i zalety wydajnościowe\nframeworka zostały w pełni potwierdzone w praktyce, zapewniając solidne podstawy\ntechnologiczne do tworzenia aplikacji na dużą skalę.","routePath":"/pl/guide/start/introduction","lang":"pl","toc":[{"text":"Tło projektu","id":"tło-projektu","depth":2,"charIndex":3},{"text":"Tło technologiczne","id":"tło-technologiczne","depth":2,"charIndex":564},{"text":"Wyzwania istniejących rozwiązań","id":"wyzwania-istniejących-rozwiązań","depth":3,"charIndex":695},{"text":"Innowacje technologiczne","id":"innowacje-technologiczne","depth":3,"charIndex":1430},{"text":"Specyfikacja techniczna","id":"specyfikacja-techniczna","depth":2,"charIndex":2419},{"text":"Wymagania środowiskowe","id":"wymagania-środowiskowe","depth":3,"charIndex":2446},{"text":"Kluczowy stos technologiczny","id":"kluczowy-stos-technologiczny","depth":3,"charIndex":2603},{"text":"Pozycjonowanie frameworka","id":"pozycjonowanie-frameworka","depth":2,"charIndex":2984},{"text":"Projekt architektoniczny","id":"projekt-architektoniczny","depth":2,"charIndex":3452},{"text":"Centralizowane zarządzanie zależnościami","id":"centralizowane-zarządzanie-zależnościami","depth":3,"charIndex":3480},{"text":"Projekt modułowy","id":"projekt-modułowy","depth":3,"charIndex":3770},{"text":"Optymalizacja wydajności","id":"optymalizacja-wydajności","depth":3,"charIndex":4017},{"text":"Dojrzałość projektu","id":"dojrzałość-projektu","depth":2,"charIndex":4311}],"domain":"","frontmatter":{"titleSuffix":"Przegląd frameworka Gez i innowacje technologiczne","description":"Poznaj tło projektu, ewolucję technologiczną i kluczowe zalety frameworka Gez, rozwiązania do nowoczesnego renderowania po stronie serwera opartego na ESM.","head":[["meta",{"property":"keywords","content":"Gez, mikrofrontendy, ESM, renderowanie po stronie serwera, SSR, innowacje technologiczne, federacja modułów"}]]},"version":""}]